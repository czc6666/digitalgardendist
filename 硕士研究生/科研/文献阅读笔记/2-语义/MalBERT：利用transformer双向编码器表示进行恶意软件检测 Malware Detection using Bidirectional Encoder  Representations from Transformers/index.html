<!doctype html>
<html lang="zh-CN">
<head>
<title>MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder Representations from Transformers</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<script async type="module">import mermaid from"https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs"</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-sv0slik/5O0JIPdLBCR2A3XDg/1U3WuDEheZfI/DI5n8Yqc3h5kjrnr46FGBNiUAJF7rE4LHKwQ/SoSLRKAxEA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script async src="https://cdn.jsdelivr.net/npm/lucide@0.115.0/dist/umd/lucide.min.js"></script>
<script>window.addEventListener("load",(()=>{document.querySelectorAll(".callout").forEach((e=>{const t=getComputedStyle(e).getPropertyValue("--callout-icon"),l=t&&t.trim().replace(/^lucide-/,"");if(l){const t=e.querySelector(".callout-title");if(t){const e=document.createElement("div"),c=document.createElement("i");e.appendChild(c),c.setAttribute("icon-name",l),e.setAttribute("class","callout-icon"),t.insertBefore(e,t.firstChild)}}})),lucide.createIcons(),Array.from(document.querySelectorAll(".callout.is-collapsible")).forEach((e=>{e.querySelector(".callout-title").addEventListener("click",(t=>{e.classList.contains("is-collapsed")?e.classList.remove("is-collapsed"):e.classList.add("is-collapsed")}))}))}))</script>
<script async src="https://fastly.jsdelivr.net/npm/force-graph@1.43.0/dist/force-graph.min.js"></script>
<script async src="https://fastly.jsdelivr.net/npm/@alpinejs/persist@3.11.1/dist/cdn.min.js"></script>
<script src="https://fastly.jsdelivr.net/npm/alpinejs@3.11.1/dist/cdn.min.js" async></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-okaidia.min.css" integrity="sha512-mIs9kKbaw6JZFfSuo+MovjU+Ntggfoj8RwAmJbVXQ5mkAX5LlgETQEweFPI18humSPHymTb5iikEOKWF7I8ncQ==" crossorigin="anonymous" referrerpolicy="no-referrer" async>
<script src="https://fastly.jsdelivr.net/npm/whatwg-fetch@3.6.2/dist/fetch.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer" async></script>
<link href="/styles/digital-garden-base.css" rel="stylesheet">
<link href="/styles/obsidian-base.css" rel="stylesheet">
<link href="/styles/_theme.74516f71.css" rel="stylesheet">
<link href="/styles/custom-style.css" rel="stylesheet">
<link rel="icon" href="/favicon.ico" sizes="any">
<link rel="icon" href="/favicon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="manifest" href="/manifest.webmanifest">
<style></style>
<style></style>
</head>
<body class="theme-light markdown-preview-view markdown-rendered markdown-preview-section css-settings-manager mod-windows is-frameless is-maximized is-hidden-frameless is-focused obsidian-app theme-light show-inline-title show-ribbon show-view-header css-settings-manager theme-default line-style-solid folder-default blockquote-normal callout-normal checkbox-default tag-default link-default heading-default responsive-tile-height oz-show-all-num">
<nav class="navbar">
<div class="navbar-inner">
<a href="/" style="text-decoration:none">
<h1 style="margin:15px!important">czc&#39;s digital garden</h1>
</a>
</div>
<div class="search-button align-icon" onclick="toggleSearch()">
<span class="search-icon">
<i icon-name="search"></i>
</span>
<span class="search-text">
<span>Search</span>
<span style="font-size:.6rem;padding:2px 2px 0 6px;text-align:center;transform:translateY(4px)" class="search-keys">
CTRL + K
</span>
</span>
</div>
</nav>
<div class="search-container" id="globalsearch" onclick="toggleSearch()">
<div class="search-box">
<input type="search" id="term" placeholder="Start typing...">
<div id="search-results"></div>
<footer class="search-box-footer">
<div class="navigation-hint">
<span>Enter to select</span>
</div>
<div class="navigation-hint align-icon">
<i icon-name="arrow-up" aria-hidden="true"></i>
<i icon-name="arrow-down" aria-hidden="true"></i>
<span>to navigate</span>
</div>
<div class="navigation-hint">
<span>ESC to close</span>
</div>
</footer>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js"></script>
<script>document.addEventListener("DOMContentLoaded",init,!1),document.addEventListener("DOMContentLoaded",setCorrectShortcut,!1),window.toggleSearch=function(){document.getElementById("globalsearch").classList.contains("active")?document.getElementById("globalsearch").classList.remove("active"):(document.getElementById("globalsearch").classList.add("active"),document.getElementById("term").focus())},window.toggleTagSearch=function(e){console.log(e.textContent);const t=e.textContent;t&&(window.document.getElementById("term").value=t.trim(),window.toggleSearch(),window.search())};const loadingSvg='\n    <svg width="100" height="100" viewBox="0 0 45 45" xmlns="http://www.w3.org/2000/svg" stroke="#fff">\n      <g fill="none" fill-rule="evenodd" transform="translate(1 1)" stroke-width="2">\n          <circle cx="22" cy="22" r="6" stroke-opacity="0">\n              <animate attributeName="r"\n                   begin="1.5s" dur="3s"\n                   values="6;22"\n                   calcMode="linear"\n                   repeatCount="indefinite" />\n              <animate attributeName="stroke-opacity"\n                   begin="1.5s" dur="3s"\n                   values="1;0" calcMode="linear"\n                   repeatCount="indefinite" />\n              <animate attributeName="stroke-width"\n                   begin="1.5s" dur="3s"\n                   values="2;0" calcMode="linear"\n                   repeatCount="indefinite" />\n          </circle>\n          <circle cx="22" cy="22" r="6" stroke-opacity="0">\n              <animate attributeName="r"\n                   begin="3s" dur="3s"\n                   values="6;22"\n                   calcMode="linear"\n                   repeatCount="indefinite" />\n              <animate attributeName="stroke-opacity"\n                   begin="3s" dur="3s"\n                   values="1;0" calcMode="linear"\n                   repeatCount="indefinite" />\n              <animate attributeName="stroke-width"\n                   begin="3s" dur="3s"\n                   values="2;0" calcMode="linear"\n                   repeatCount="indefinite" />\n          </circle>\n          <circle cx="22" cy="22" r="8">\n              <animate attributeName="r"\n                   begin="0s" dur="1.5s"\n                   values="6;1;2;3;4;5;6"\n                   calcMode="linear"\n                   repeatCount="indefinite" />\n          </circle>\n      </g>\n  </svg>';function debounce(e,t,n){var a;return function(){var r=this,i=arguments,c=n&&!a;clearTimeout(a),a=setTimeout((function(){a=null,n||e.apply(r,i)}),t),c&&e.apply(r,i)}}function setCorrectShortcut(){navigator.platform.toUpperCase().indexOf("MAC")>=0&&document.querySelectorAll(".search-keys").forEach((e=>e.innerHTML="⌘ + K"))}function createIndex(e){const t=e=>e.toLowerCase().split(/([^a-z]|[^\x00-\x7F])/),n=new FlexSearch.Document({cache:!0,charset:"latin:extra",optimize:!0,index:[{field:"content",tokenize:"reverse",encode:t},{field:"title",tokenize:"forward",encode:t},{field:"tags",tokenize:"forward",encode:t}]});return e.forEach(((e,t)=>{n.add({id:t,title:e.title,content:e.content,tags:e.tags})})),n}async function init(){let e=!0;if(localStorage.getItem("searchIndex")){let{date:t,docs:n}=JSON.parse(localStorage.getItem("searchIndex"));if("2025-06-04T08:42:55.853Z"===t){e=!1;let t=createIndex(n);window.docs=n,window.index=t}}if(e){let e=await(await fetch("/searchIndex.json?v=2025-06-04T08:42:55.853Z")).json(),t=createIndex(e);localStorage.setItem("searchIndex",JSON.stringify({date:"2025-06-04T08:42:55.853Z",docs:e})),window.docs=e,window.index=t}document.addEventListener("keydown",(e=>{if((e.ctrlKey||e.metaKey)&&"k"===e.key&&(e.preventDefault(),toggleSearch()),"Escape"===e.key&&document.getElementById("globalsearch").classList.remove("active"),document.getElementById("globalsearch").classList.contains("active")){if("ArrowDown"===e.key){e.preventDefault();let t=document.querySelector(".searchresult.active");t?(t.classList.remove("active"),t.nextElementSibling?t.nextElementSibling.classList.add("active"):document.querySelector(".searchresult").classList.add("active")):document.querySelector(".searchresult").classList.add("active");let n=document.querySelector(".searchresult.active");n&&n.scrollIntoView({behavior:"smooth",block:"nearest",inline:"start"})}if("ArrowUp"===e.key){e.preventDefault();let t=document.querySelector(".searchresult.active");t?(t.classList.remove("active"),t.previousElementSibling?t.previousElementSibling.classList.add("active"):document.querySelectorAll(".searchresult").forEach((e=>{e.nextElementSibling||e.classList.add("active")}))):document.querySelectorAll(".searchresult").forEach((e=>{e.nextElementSibling&&e.classList.add("active")}));let n=document.querySelector(".searchresult.active");n&&n.scrollIntoView({behavior:"smooth",block:"nearest",inline:"start"})}if("Enter"===e.key){e.preventDefault();let t=document.querySelector(".searchresult.active");t&&(window.location.href=t.querySelector("a").href)}}}));const t=debounce(search,200,!1);field=document.querySelector("#term"),field.addEventListener("keydown",(e=>{"ArrowDown"!==e.key&&"ArrowUp"!==e.key&&t()})),resultsDiv=document.querySelector("#search-results");const n=new URL(location.href).searchParams;n.get("q")&&(field.setAttribute("value",n.get("q")),toggleSearch(),search())}async function search(){let e=field.value.trim();if(!e)return;if(e==lastSearch)return;console.log(`search for ${e}`),window.lastSearch=e,resultsDiv.innerHTML=loadingSvg;let t=offlineSearch(e),n="";if(!t.length){let t=document.createElement("p");return t.innerText=`No results for "${e}"`,resultsDiv.innerHTML="",void resultsDiv.appendChild(t)}n+='<div style="max-width:100%;">',t.forEach((e=>{e.tags&&e.tags.length>0?n+=`<div class="searchresult">\n                    <a class="search-link" href="${e.url}">${e.title}</a>\n                    <div onclick="window.location='${e.url}'">\n                        <div class="header-meta">\n                            <div class="header-tags">\n                                ${e.tags.map((e=>'<a class="tag" href="JavaScript:Void(0);">#'+e+"</a>")).join("")}\n                            </div>\n                        </div>\n                        ${e.content}\n                    </div>\n                </div>`:n+=`<div class="searchresult">\n                    <a class="search-link" href="${e.url}">${e.title}</a>\n                    <div onclick="window.location='${e.url}'">\n                        ${e.content}\n                    </div>\n                </div>`})),n+="</div>",resultsDiv.innerHTML=n}function truncate(e,t){return(e=e.replaceAll(/<[^>]*>/g,"")).length<t?e:e.substring(0,t-3)+"..."}function offlineSearch(e){let t=window.docs,n="#"===e[0]&&e.length>1?index.search(e.substring(1),[{field:"tags"}]):index.search(e,[{field:"title",limit:5},{field:"content",weight:10}]);const a=e=>{const t=n.filter((t=>t.field===e));return 0===t.length?[]:[...t[0].result]};return[...new Set([...a("title"),...a("content"),...a("tags")])].map((e=>{let n=t[e];return n.content=truncate(n.content,400),n.tags=n.tags.filter((e=>"gardenEntry"!=e&&"note"!=e)),n}))}window.lastSearch=""</script>
<main class="content cm-s-obsidian">
<header>
<h1 data-note-icon="">MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder Representations from Transformers</h1>
<div class="header-meta">
<div class="header-tags">
</div>
<div class="timestamps"><div><i icon-name="calendar-plus"></i> <span class="human-date" data-date="2025-03-05T23:19:10.769+08:00"></span></div><div><i icon-name="calendar-clock"></i> <span class="human-date" data-date="2025-03-12T13:51:50.430+08:00"></span></div></div></div>
</header>
<p>MalBERT：利用transformer双向编码器表示进行恶意软件检测</p>
<h2 id="摘要：" tabindex="-1">摘要：</h2>
<p>~~近年来，我们目睹了不同平台上的网络威胁和恶意软件攻击的增加，给个人和企业带来了重要后果。找到自动机器学习技术来主动防御恶意软件已经变得至关重要。变形金刚是一种基于注意力的深度学习技术，最近在解决主要与自然语言处理（NLP）领域相关的不同任务方面显示出令人印象深刻的结果。~~在本文中，我们提出使用transformer架构来自动检测恶意软件。我们提出了MalBERT，一个基于BERT（来自变形金刚的双向编码器表示）的模型，它使用预处理特征对Android应用程序的源代码进行静态分析，以表征现有恶意软件并将其分类为不同的代表性恶意软件类别。结果表明，基于变压器的模型在恶意软件检测中具有很高的性能。</p>
<h2 id="1" tabindex="-1">1 介绍</h2>
<p>由于数字设备使用的指数级增长和互联网技术的易于访问，对计算机和智能手机等信息系统的网络威胁正在增加。恶意软件（Malware）是攻击者进行网络攻击的主要工具。木马、adware和Risktools等不同类型的恶意软件正在迅速发展，并随着最新的加密和变形技术而更新，成为对网络空间的更严重威胁。这种快速发展的事件往往对个人和企业层面的不同数据用户造成有害后果。例如，IBM报告称，截至2020年，数据泄露的平均成本为386万美元，然而，识别泄露的平均时间为207天。因此，IT安全专业人员和研究人员需要更新可用的工具来自动检测新的恶意软件攻击。为了解决这个问题，进行了一系列的研究。在静态、动态和混合级别[2]上进行不同的分析实验，提取二进制文件、权限和API调用等各种类型的特征。收集到的特征然后通过使用机器学习和深度学习工具开发的检测模型进行传递。例如，深度学习算法的使用帮助安全专家分析最复杂和最具针对性的攻击。广泛使用的方法类型是静态分析[3]。这是一种在良性应用程序中识别恶意应用程序的已知方法，本分析侧重于可能受恶意软件影响的软件组件的源代码。由于不需要通过执行代码来激活恶意软件来捕获特性，因此它在资源和时间方面花费较少，它可以在代码级别识别恶意软件。对于静态分析，主要有三种方法来检测和分类恶意软件：<strong>基于权限</strong>（验证应用程序是否需要请求的权限，以确保应用程序访问和使用用户数据的正常行为），<strong>基于签名</strong>（识别应用程序签名是否与预先收集的库中的恶意软件签名之一相匹配），以及<strong>基于规范</strong>（验证应用程序是否违反了专家制定的规则，以确定被检查程序的恶意）。</p>
<p>最近对深度学习的研究导致了基于transformer的模型的开发，例如BERT[4]和XLNet[5]。这些方法在各种最先进的自然语言处理（NLP）[7]和计算机视觉[7]任务中清楚地显示出令人印象深刻的结果。由于在编码器-解码器架构中添加了注意机制层[8]，Transformers可以专注于数据中最重要的模式，从而显著提高了性能。</p>
<p>在本文中，我们提出了一种基于transformer算法的恶意软件检测方法。我们在数据上使用不同的Transformer模型架构进行实验。该数据集包括11种不同的恶意软件类别，即广告软件、间谍软件、勒索软件、点击器、丢弃器、下载器、风险软件、短信发送器、木马、后门和银行家 <code>[9] [10]</code>。我们的方法侧重于Android应用程序源代码的静态分析级别，以识别不同类别的恶意软件。实际上，我们并没有将特性限制在基于权限的范围内，而是将整个软件代码视为分析的重要特征表示集。<strong>我们首先用预处理后的特征训练模型，然后对应用程序进行恶意和良性的二元分类，最后在恶意软件级别进行跨类别分类。</strong></p>
<h2 id="2" tabindex="-1">2 背景</h2>
<p>通常，序列到序列的任务是使用编码器-解码器模型执行的。RNN（循环和递归网络）架构是编码器和解码器最广泛使用的架构。但是这些架构有一些局限性。</p>
<p>a:RNN<br>
RNN或也称为序列建模，如LSTM[11]，是处理序列数据的神经网络家族。将x值的输入序列映射到相应的输出0值序列[11]的循环网络。损失L衡量每个O与相应训练目标的距离为b[11]。loss L在内部计算y = so f tmax(O)，并将其与目标y[11]进行比较。就局限性而言，基于RNN的架构很难并行化，因为前向传播图本质上是顺序的，每个时间步可能只在前一个时间步之后计算，其中运行时和内存成本都是O(t)，并且无法减少，因为在前向传递中计算的状态必须排序，直到它们在向后传递期间被重用。</p>
<p>b . Encoder-Decoder<br>
seq2seq模型通常有一个编码器-解码器架构[12]，由一个编码器组成，该编码器处理输入序列并将信息压缩成固定长度的上下文向量。这种表示形式可以很好地概括整个源序列的含义。以及一个解码器，该解码器使用上下文向量初始化以发出转换后的输出。编码器-解码器模型的平均限制是这种固定长度上下文向量设计的缺点，并且不能记忆长句子。而解码器在不同的时间步长需要不同的信息。</p>
<p>c .transformer<br>
因此，为了解决RNN和编解码器架构的局限性，变形金刚[8]的作者提出了一个解决方案。他们依靠seq2seq编码器解码器，用注意力机制取代RNN。注意力机制让变形金刚拥有非常长的记忆。Transformer模型可以“关注”或“关注”所有已生成的先前token。注意机制允许解码器回溯整个句子，并有选择地提取解码过程中需要的信息。注意力机制使解码器能够访问编码器的所有隐藏状态。然而，解码器仍然需要对下一个单词进行单个预测，所以我们不能只传递整个序列给它（我们必须传递某种合成向量）。因此，它要求解码器通过对隐藏状态进行加权来选择使用哪些隐藏状态以及忽略哪些隐藏状态。然后，解码器接收隐藏状态的加权和，用于预测下一个单词。在本节中，我们通过展示与它们的体系结构相关的大多数方法来定义基于transformer的方法的上下文。NLP中的Transformer是一种新的体系结构，旨在解决序列到序列的任务，同时轻松管理远程依赖关系。在b[8]中提出了Transformer。Transformer是一种架构，它避免了重复，并完全依赖于注意机制来绘制输入和输出之间的全局依赖关系。在《变形金刚》之前，主导序列转导模型是基于复杂的循环或卷积神经网络，包括一个编码器和一个解码器。变压器也使用一个编码器和一个解码器，但是为了支持注意机制而消除了递归，这比rnn和cnn等方法允许更大的并行化。与基于RNN的seq2seq模型相比，这种转换无疑是一个巨大的改进。但它也有自己的局限性。只能注意固定长度的文本字符串。在作为输入输入到系统中之前，文本必须被分割成许多片段或片段，这会导致上下文碎片化。例如，BERT[4]是谷歌AI的一种新的语言表示模型，它使用预训练和微调来为广泛的任务创建最先进的模型。这些任务包括问答系统、情感分析和语言推理。迁移学习已在NLP中使用具有转换架构的预训练语言模型。BERT的实现通过使用预先形成的掩码语言模型（MLM）目标[13]消除了单向性的约束，从而改进了标准变压器。被屏蔽语言模型随机屏蔽输入的某些元素，目标是仅根据其上下文预测被屏蔽词的原始词汇标识符。与预训练从左到右的语言模型不同，MLM的目标允许表示合并左右上下文，这允许我们预训练深度双向Transformer。除了掩码语言模型。BERT使用下一个句子预测任务来联合预训练文本对表示。此外，RoBERTa b[14]是BERT的扩展，在体系结构的预训练过程中进行了一些修改，使用了相同的体系结构。修改包括训练模型的时间更长，批次更大，数据量更大。作者对训练数据的掩蔽方案[13]进行了动态修改，使模型能够预测更长的序列。他们还收集了一个与其他私人使用的数据集大小相当的新数据集，以更好地控制训练集大小的影响。为了减少BERT的计算和训练时间，Sanh等人提出了一种基于BERT架构的小型、快速、廉价、轻量级的Transformer模型DistilBERT[15]。这个新的扩展在预训练阶段使用知识蒸馏[16]将BERT模型的大小减少了40%。为了利用大型模型在预训练过程中习得的归纳偏差，作者引入了三重损失组合，即；语言建模损失、蒸馏损失和余弦距离损失。另一种基于Transformer体系结构的方法是自回归Transformer。XLNet[5]是这种新实现的一个例子，它充分利用了建模和自动语言编码的优点，同时试图避免其局限性。XLNet没有像经典的自回归模型那样使用固定的前向或后向分解顺序，而是使用分解顺序[6]的所有可能排列最大化序列的期望对数概率。此外，由于使用了置换操作，每个位置的上下文可以由left和right标记组成，这使XLNet能够捕获所有位置的双向上下文信息。在本文中，我们通过对二进制和跨类别恶意软件检测任务进行一系列实验，使用所提出的模型来评估我们提出的方法。</p>
<h2 id="3" tabindex="-1">3 相关工作</h2>
<p>在过去的几年里，人们在深度学习中提出了各种检测恶意软件的方法。这些现有的方法主要分为；一方面对循环神经网络（RNN）和卷积神经网络（CNN）在不同的特征提取集上进行训练，另一方面利用注意机制特征对恶意软件进行分类。</p>
<h3 id="a" tabindex="-1">A.基于神经网络的方法</h3>
<p>在这些方法中，b[17]的研究构建了AMalNet，这是一个使用图CNN （GCNs）学习多个集成表示和家族分配的框架，用于建模高级图语义，并使用独立RNN （IndRNN）解码深层语义信息。SeqMobile[18]是一种基于行为的序列方法，使用不同的循环神经网络（RNN）。在一定的时间约束下，从二进制文件中提取能够提供某种恶意行为信息的语义特征序列。Niu等人提出了一种基于opcode级FCG的新方法。FCG是通过使用长短期记忆（LSTM）对操作码（OpCode）进行静态分析获得的。作者在1796个Android恶意软件样本（分为两类）和1000个良性Android应用程序的数据集上进行了实验。Jha等人使用RNN将步长作为影响输入大小的重要因素。他们使用超参数用三种不同的特征向量（热编码特征向量、随机特征向量和Word2Vec特征向量）测试了模型。Farid et al.[21]使用预定义字典和智能映射将android package kit （APK）文件转换为轻量级RGB图像，然后对获得的图像应用CNN进行恶意软件族分类。已经开发了多个基于深度神经网络的方法[22]，[23]的其他示例，采用不同的特征提取，选择和表示方法，目的是提高检测结果。</p>
<p>B.使用注意机制的方法</p>
<p>据我们所知，我们的方法是第一个直接在软件应用程序和预处理功能（如文本）上实现变形金刚的研究，以检测恶意软件，很少有方法尝试使用新方法（如注意力机制）的第一步。例如，Chen等人提出了SLAM，这是一种基于注意机制的特点和滑动窗口方法构建的恶意软件检测框架。根据API执行序列的语义，采用了一种特征提取方法。[25]采用了基于残差注意的机制，在此基础上提出的方法优于传统的CNN模型。同样，Zhang等人[26]提出了一种基于一组Ngram操作码序列补丁的静态分析框架，该框架具有基于自注意的CNN，名为SA-CNN。Yakura et al.[27]提出的另一个例子，将具有注意机制的CNN应用于从二值数据集转换而来的图像，通过计算注意图提取特征字节序列。注意图中区域的区分表明图像中对分类具有较高重要性的区域。在我们的工作中，我们提出了一种基于BERT的新方法来更好地检测恶意软件。我们改进了预训练模型，以有效地学习源代码语言语法和语义的表示。我们的上下文感知网络从自然语言句子的角度学习上下文特征，这要归功于基于transformer的架构中的注意机制层。</p>
<h2 id="4" tabindex="-1">4 方法</h2>
<p>介绍恶意软件检测的总体流程。这项工作的核心思想是使用基于transformer的方法创建一个恶意软件检测框架。为了达到这一目标，我们从自然语言句子的角度对收集到的语料库进行了静态分析。所以，我们需要一个数据集，包括源代码文件和不同类别的恶意软件类型。图1解释了Android恶意软件检测的逻辑流程。这个过程主要分为4个阶段。首先是Android文件的收集，然后是APK文件的反编译阶段，进行特征挖掘，最后是深度学习（Deep Learning， DL）模型训练实验。<br>
<picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image.png"><source media="(max-width:480px)" srcset="/img/optimized/sUmRk-sxWU-452.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/sUmRk-sxWU-452.jpeg">
<img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image.png" width=""></picture></p>
<h3 id="a-1" tabindex="-1">A.数据收集</h3>
<p>我们从Androzoo公共数据集中收集Android应用程序。Androzoo是最先进的android恶意软件数据集之一，是一个不断增长的android应用程序的集合，来自几个来源，包括官方的谷歌Play应用程序市场。它目前包含13,320,014个不同的apk，每个apk都经过数十种不同的防病毒产品的分析，以找出哪些应用程序被检测为恶意软件。这些公共数据是每周对样本进行分析的最新数据。根据这些分析，数据被标记为恶意软件和良性软件，以及不同的恶意软件类别和家族。</p>
<p><picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image-1.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image-1.png"><source media="(max-width:480px)" srcset="/img/optimized/S9Sqwl8wlh-443.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/S9Sqwl8wlh-443.jpeg">
<img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image-1.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image-1.png" width=""></picture></p>
<p>基于Android恶意软件类别b[30][31]的最新分类法，我们选择了11个类别，即；广告软件（显示广告并诱使用户在其设备上安装广告），间谍软件（在用户不知情的情况下安装在用户设备上，目的是收集和传输信息），勒索软件（以个人数据为人质），点击器（一种执行广告欺诈形式的特洛伊木马）。这些“点击者”不断地与网站建立连接，从而向威胁行为者提供按点击付费的收入)，滴管程序（注射器程序或滴管病毒，是一种为在目标系统上安装恶意软件而创建的计算机程序），下载程序（一种下载和安装恶意文件的特洛伊木马），风险软件（一种安装可能对计算机安全构成风险的软件，但并非不可避免），短信发送者（将自己呈现为普通的短信应用程序，并使用其基本权限发送/接收短信），木马（旨在破坏，破坏，窃取或通常对您的数据或网络施加一些其他有害行为），后门（当引入设备时，通常在用户不知情的情况下，将软件变成特洛伊木马），银行家（旨在窃取用户在线银行账户的数据，以及在线支付系统和塑料卡系统的数据）。图2表示这些类别在我们的数据集中的分布。我们根据最近的创建和分析日期选择要下载的apk列表，然后使用VirusTotal[32]重新分析该列表，最终创建我们的数据集列表，包括12,000个良性应用程序和10,000个恶意应用程序。</p>
<h3 id="b" tabindex="-1">B.预处理和特征表示</h3>
<p>定义了apk列表之后，我们编写一个脚本来下载这些文件。然后，我们使用Jdax[33]对下载的apk进行反编译，这将创建应用程序文件[34]文件夹。我们从每个示例中提取Manifest.xml文件。该文件提供了有关应用程序的基本信息，包括权限列表、活动、服务、广播接收器、内容提供程序、版本和元数据。然后将这些文件解析为文本格式，并通过预处理阶段。在这一步中，我们对不重要的，大多是重复的单词进行具体的清洗。我们手动分析了不同的例子，并创建了一个不提供额外信息的单词和短语列表。预处理的目的是将输入大小减少到Transformer指定的令牌限制。最终的数据集格式有4列，ID列，由APK哈希名称表示，Text列表示预处理后的Manifest文件，Label列，如果应用程序是恶意软件等于1，如果不是等于0的二进制格式，最后Category列表示恶意软件类型名称（exp: adware）。</p>
<h3 id="c" tabindex="-1">C.建议的方法</h3>
<p>一旦数据被创建并以正确的格式注释，我们将数据分成训练和测试。我们使用BERT进行所有的实验，我们在我们的火车数据集上对它进行了微调。我们根据每种分类类型固定了超参数。我们训练BERT来预测每个样本的恶意软件/良性（即二元分类），然后预测恶意软件的类别（即多重分类）。Transformer体系结构具有特定的输入格式化步骤，包括创建特殊的令牌和id。我们使用Transformers实现的拥抱脸库[35]对Android应用程序进行二进制分类。只有Transformer架构、层和权重被实现，而所有的数据格式化必须事先完成以与Transformer兼容。而大多数预训练的变形金刚基本上都有相同的步骤。这里我们用BERT测试这种方法。图3给出了我们的方法的详细概述。</p>
<p><picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image-2.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image-2.png"><source media="(max-width:480px)" srcset="/img/optimized/sOehk7iiEV-465.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/sOehk7iiEV-465.jpeg">
<img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image-2.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image-2.png" width=""></picture></p>
<h2 id="5" tabindex="-1">5 实验结果</h2>
<p>为了测试所提出的方法，我们从三个主要方面对其进行了评估：(1)在大型和最新分类数据集上的盈利能力，(2)从android应用程序中提取信息上下文的特征表示能力，以及(3)与最先进方法相比的性能。</p>
<p>答:参数</p>
<p>预训练的BERT基础模型（uncase）具有52000单词嵌入词汇表大小，6层，位置嵌入权重为514。我们保持这些值的所有参数，并开始微调。在我们的调优实现中，我们使用Adam优化器并将其超参数设置如下：二元分类的学习率α ~ 2e-5，多元分类的学习率α ~ e-3， α1=0,9, α2=0,999。我们将最大序列大小设置为512，训练批大小设置为32。对于特征创建，我们使用BERT标记器，Keras填充序列，然后使用BERT序列进行分类。</p>
<p>b .基线</p>
<p>我们将所提出的模型与包括LSTM[36]在内的几种最新方法进行了比较。我们根据其在综述研究中的表现选择了该测序模型。我们还使用XLNet[5]、RoBERTa[14]和DistilBERT[15]作为基于Transformer的基线，将它们的性能与BERT进行比较。</p>
<p>C.评估指标</p>
<p>为了评估模型的有效性并避免由于训练集和测试集的划分而导致的偶然性，我们选择了分类问题中常用的三个指标（准确率、MCC和损失）来评估模型。我们定义以下数字；TP（真阳性），FN（假阴性），FP（假阳性）和TN（真阴性）。准确度（ACC）是评价分类模型的一个指标。它等于正确预测次数除以预测总数，如式1所示：</p>
<p><picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image-3.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image-3.png"><source media="(max-width:480px)" srcset="/img/optimized/9VSvCQTM0D-400.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/9VSvCQTM0D-400.jpeg">
<img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image-3.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image-3.png" width=""></picture></p>
<p>马修斯相关系数（MCC）用于非平衡数据集的二值分类。它的取值范围是-1到+1。根据Chicco等人的推荐，我们选择MCC而不是F1-score进行二元分类。MCC方程定义如下：</p>
<p><picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image-4.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image-4.png"><source media="(max-width:480px)" srcset="/img/optimized/mi7IyQaVdj-391.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/mi7IyQaVdj-391.jpeg">
<img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image-4.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image-4.png" width=""></picture></p>
<p>标准f1分数的公式是查准率和查全率的调和平均值。一个完美的模型的f值是1。在本文的结果中，我们使用了宏观平均。F1-score的公式定义如下：</p>
<p><picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image-5.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image-5.png"><source media="(max-width:480px)" srcset="/img/optimized/nP2jezPhaY-349.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/nP2jezPhaY-349.jpeg">
<img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image-5.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image-5.png" width=""></picture></p>
<p>对于损失函数，我们使用交叉熵损失，或对数损失[38]。它测量输出在0到1之间的概率值的分类模型的性能。交叉熵损失随着预测概率偏离实际标签而增加。概率分布p相对于概率分布q的交叉熵H（p, q）表示为：</p>
<p><picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image-6.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image-6.png"><source media="(max-width:480px)" srcset="/img/optimized/s7Z5QWERUq-370.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/s7Z5QWERUq-370.jpeg">
<img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image-6.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image-6.png" width=""></picture></p>
<p>D.结果与分析</p>
<p>我们在预处理后的数据集上进行了实验。与LSTM基线相比，对预训练模型进行微调，显然为该分类任务提供了最高准确率的结果。最好的分类模型是BERT。表1的测试指标结果显示，每个Transformer根据不同的体系结构进行不同的学习。表1和表2的结果证明BERT在二进制和多分类恶意软件检测方面都优于其他基线模型。对于BERT来说，最佳学习率表明在损失开始增加之前只需要两个epoch。我们对训练集的微调包括改变超参数来提高结果。为了评估最终结果，我们使用了不同的评估指标。预训练模型总体上取得了很好的效果，但BERT在两个任务中都获得了最好的表现。</p>
<p><picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image-7.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image-7.png"><source media="(max-width:480px)" srcset="/img/optimized/z4teBF177p-500.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/z4teBF177p-500.jpeg">
<source media="(max-width:1920px)" srcset="/img/optimized/z4teBF177p-503.webp" type="image/webp"><source media="(max-width:1920px)" srcset="/img/optimized/z4teBF177p-503.jpeg"><img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/MalBERT%EF%BC%9A%E5%88%A9%E7%94%A8transformer%E5%8F%8C%E5%90%91%E7%BC%96%E7%A0%81%E5%99%A8%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%20Malware%20Detection%20using%20Bidirectional%20Encoder%20%20Representations%20from%20Transformers_image-7.png" alt="MalBERT：利用transformer双向编码器表示进行恶意软件检测 Malware Detection using Bidirectional Encoder  Representations from Transformers_image-7.png" width=""></picture></p>
<p>本文采用一种新的基于Transformer的恶意软件分类方法进行研究。我们详细介绍了恶意软件文本分类方法，并将其用于特征表示。与其他基线预训练语言模型相比，基于bert的模型在二元分类和跨类别分类方面都取得了较高的准确率。实验结果表明，二值分类的最佳准确率为0.9761，多分类的最佳准确率为0.9102。我们可以得出结论，提出的方法结果特征表示作为文本输入的基于transformer的模型，是非常有趣的。因此，在网络安全任务中，基于Transformer架构的预训练语言模型的实现在应用于Androzoo等最先进的数据集时，可以优于LSTM等标准RNN模型。未来的工作包括在其他数据集上测试MalBERT，使用其他transformer模型（如GPT3）进行测试，并创建一个API来自动检测新应用程序中的恶意软件。</p>
</main>
<aside>
<div class="sidebar">
<div class="sidebar-container">
<div class="toc">
<div class="toc-title-container">
<div class="toc-title">
On this page
</div>
</div>
<div class="toc-container">
<nav class="toc">
<ol>
<li><a href="#摘要：">摘要：</a>
</li>
<li><a href="#1">1 介绍</a>
</li>
<li><a href="#2">2 背景</a>
</li>
<li><a href="#3">3 相关工作</a>
<ol>
<li><a href="#a">A.基于神经网络的方法</a>
</li>
</ol>
</li>
<li><a href="#4">4 方法</a>
<ol>
<li><a href="#a-1">A.数据收集</a>
</li>
<li><a href="#b">B.预处理和特征表示</a>
</li>
<li><a href="#c">C.建议的方法</a>
</li>
</ol>
</li>
<li><a href="#5">5 实验结果</a>
</li>
</ol>
</nav>
</div>
</div>
<div class="backlinks">
<div class="backlink-title" style="margin:4px 0!important">Pages mentioning this page</div>
<div class="backlink-list"><div class="backlink-card"><i icon-name="link"></i><a href="/硕士研究生/科研/文献阅读笔记/文献阅读笔记/" data-note-icon="" class="backlink">文献阅读笔记</a>
</div></div>
</div>
</div>
</div>
</aside>
<style>#tooltip-wrapper{background:var(--background-primary);padding:1em;border-radius:4px;overflow:hidden;position:fixed;width:80%;max-width:400px;height:auto;max-height:300px;font-size:.8em;box-shadow:0 5px 10px rgba(0,0,0,.1);opacity:0;transition:opacity .1s;unicode-bidi:plaintext;overflow-y:scroll;z-index:10}#tooltip-wrapper:after{content:"";position:absolute;z-index:1;bottom:0;left:0;pointer-events:none;width:100%;unicode-bidi:plaintext;height:75px}</style>
<div style="opacity:0;display:none" id="tooltip-wrapper">
<div id="tooltip-content">
</div>
</div>
<iframe style="display:none;height:0;width:0" id="link-preview-iframe" src="">
</iframe>
<script>var opacityTimeout,contentTimeout,transitionDurationMs=100,iframe=document.getElementById("link-preview-iframe"),tooltipWrapper=document.getElementById("tooltip-wrapper"),tooltipContent=document.getElementById("tooltip-content"),linkHistories={};function hideTooltip(){opacityTimeout=setTimeout((function(){tooltipWrapper.style.opacity=0,contentTimeout=setTimeout((function(){tooltipContent.innerHTML="",tooltipWrapper.style.display="none"}),transitionDurationMs+1)}),transitionDurationMs)}function showTooltip(t){var e=t.target,o=e.getClientRects()[e.getClientRects().length-1],i=window.pageYOffset||document.documentElement.scrollTop,n=t.target.getAttribute("href");if(-1===n.indexOf("http")||-1!==n.indexOf(window.location.host)){let t=n.split("#")[0];linkHistories[t]?(tooltipContent.innerHTML=linkHistories[t],tooltipWrapper.style.display="block",setTimeout((function(){if(tooltipWrapper.style.opacity=1,-1!=n.indexOf("#")){let t=n.split("#")[1];const e=tooltipWrapper.querySelector(`[id='${t}']`);e.classList.add("referred"),e.scrollIntoView({behavior:"smooth"},!0)}else tooltipWrapper.scroll(0,0)}),1)):(iframe.src=t,iframe.onload=function(){tooltipContentHtml="",tooltipContentHtml+='<div style="font-weight: bold; unicode-bidi: plaintext;">'+iframe.contentWindow.document.querySelector("h1").innerHTML+"</div>",tooltipContentHtml+=iframe.contentWindow.document.querySelector(".content").innerHTML,tooltipContent.innerHTML=tooltipContentHtml,linkHistories[t]=tooltipContentHtml,tooltipWrapper.style.display="block",tooltipWrapper.scrollTop=0,setTimeout((function(){if(tooltipWrapper.style.opacity=1,-1!=n.indexOf("#")){let t=n.split("#")[1];const e=tooltipWrapper.querySelector(`[id='${t}']`);e.classList.add("referred"),console.log(e),e.scrollIntoView({behavior:"smooth"},!0)}else tooltipWrapper.scroll(0,0)}),1)}),tooltipWrapper.style.left=o.left-tooltipWrapper.offsetWidth/2+o.width/2+"px",window.innerHeight-o.top<tooltipWrapper.offsetHeight?tooltipWrapper.style.top=o.top+i-tooltipWrapper.offsetHeight-10+"px":window.innerHeight-o.top>tooltipWrapper.offsetHeight&&(tooltipWrapper.style.top=o.top+i+35+"px"),o.left+o.width/2<tooltipWrapper.offsetWidth/2?tooltipWrapper.style.left="10px":document.body.clientWidth-o.left-o.width/2<tooltipWrapper.offsetWidth/2&&(tooltipWrapper.style.left=document.body.clientWidth-tooltipWrapper.offsetWidth-20+"px")}}function setupListeners(t){t.addEventListener("mouseleave",(function(t){hideTooltip()})),tooltipWrapper.addEventListener("mouseleave",(function(t){hideTooltip()})),t.addEventListener("mouseenter",(function(t){clearTimeout(opacityTimeout),clearTimeout(contentTimeout),showTooltip(t)})),tooltipWrapper.addEventListener("mouseenter",(function(t){clearTimeout(opacityTimeout),clearTimeout(contentTimeout)}))}window.addEventListener("load",(function(t){document.querySelectorAll(".internal-link").forEach(setupListeners),document.querySelectorAll(".backlink-card a").forEach(setupListeners)}))</script>
<script>window.location.hash&&document.getElementById(window.location.hash.slice(1)).classList.add("referred"),window.addEventListener("hashchange",(e=>{const t=e.oldURL.split("#");t[1]&&document.getElementById(t[1]).classList.remove("referred");const n=e.newURL.split("#");n[1]&&document.getElementById(n[1]).classList.add("referred")}),!1);const url_parts=window.location.href.split("#"),url=url_parts[0],referrence=url_parts[1];document.querySelectorAll(".cm-s-obsidian > *[id]").forEach((function(e){e.ondblclick=function(e){const t=url+"#"+e.target.id;navigator.clipboard.writeText(t)}}))</script>
<script src="https://fastly.jsdelivr.net/npm/luxon@3.2.1/build/global/luxon.min.js"></script>
<script defer="defer">TIMESTAMP_FORMAT="MMM dd, yyyy h:mm a",document.querySelectorAll(".human-date").forEach((function(e){date=e.getAttribute("data-date")||e.innerText,parsed_date=luxon.DateTime.fromISO(date),null!=parsed_date.invalid&&(parsed_date=luxon.DateTime.fromSQL(date)),null!=parsed_date.invalid&&(parsed_date=luxon.DateTime.fromHTML(date)),e.innerHTML=parsed_date.toFormat(TIMESTAMP_FORMAT)}))</script>
<script>lucide.createIcons({attrs:{class:["svg-icon"]}})</script>
</body>
</html>
