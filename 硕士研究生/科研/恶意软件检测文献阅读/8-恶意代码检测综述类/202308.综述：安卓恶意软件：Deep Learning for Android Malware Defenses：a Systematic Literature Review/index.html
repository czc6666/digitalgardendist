<!doctype html>
<html lang="zh-CN">
<head>
<title>202308.综述：安卓恶意软件：Deep Learning for Android Malware Defenses：a Systematic Literature Review</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<script async type="module">import mermaid from"https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs"</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-sv0slik/5O0JIPdLBCR2A3XDg/1U3WuDEheZfI/DI5n8Yqc3h5kjrnr46FGBNiUAJF7rE4LHKwQ/SoSLRKAxEA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script async src="https://cdn.jsdelivr.net/npm/lucide@0.115.0/dist/umd/lucide.min.js"></script>
<script>window.addEventListener("load",(()=>{document.querySelectorAll(".callout").forEach((e=>{const t=getComputedStyle(e).getPropertyValue("--callout-icon"),l=t&&t.trim().replace(/^lucide-/,"");if(l){const t=e.querySelector(".callout-title");if(t){const e=document.createElement("div"),c=document.createElement("i");e.appendChild(c),c.setAttribute("icon-name",l),e.setAttribute("class","callout-icon"),t.insertBefore(e,t.firstChild)}}})),lucide.createIcons(),Array.from(document.querySelectorAll(".callout.is-collapsible")).forEach((e=>{e.querySelector(".callout-title").addEventListener("click",(t=>{e.classList.contains("is-collapsed")?e.classList.remove("is-collapsed"):e.classList.add("is-collapsed")}))}))}))</script>
<script async src="https://fastly.jsdelivr.net/npm/force-graph@1.43.0/dist/force-graph.min.js"></script>
<script async src="https://fastly.jsdelivr.net/npm/@alpinejs/persist@3.11.1/dist/cdn.min.js"></script>
<script src="https://fastly.jsdelivr.net/npm/alpinejs@3.11.1/dist/cdn.min.js" async></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-okaidia.min.css" integrity="sha512-mIs9kKbaw6JZFfSuo+MovjU+Ntggfoj8RwAmJbVXQ5mkAX5LlgETQEweFPI18humSPHymTb5iikEOKWF7I8ncQ==" crossorigin="anonymous" referrerpolicy="no-referrer" async>
<script src="https://fastly.jsdelivr.net/npm/whatwg-fetch@3.6.2/dist/fetch.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer" async></script>
<link href="/styles/digital-garden-base.css" rel="stylesheet">
<link href="/styles/obsidian-base.css" rel="stylesheet">
<link href="/styles/_theme.74516f71.css" rel="stylesheet">
<link href="/styles/custom-style.css" rel="stylesheet">
<link rel="icon" href="/favicon.ico" sizes="any">
<link rel="icon" href="/favicon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="manifest" href="/manifest.webmanifest">
<style></style>
<style></style>
</head>
<body class="theme-light markdown-preview-view markdown-rendered markdown-preview-section css-settings-manager mod-windows is-frameless is-maximized is-hidden-frameless is-focused obsidian-app theme-light show-inline-title show-ribbon show-view-header css-settings-manager theme-default line-style-solid folder-default blockquote-normal callout-normal checkbox-default tag-default link-default heading-default responsive-tile-height oz-show-all-num">
<nav class="navbar">
<div class="navbar-inner">
<a href="/" style="text-decoration:none">
<h1 style="margin:15px!important">czc&#39;s digital garden</h1>
</a>
</div>
<div class="search-button align-icon" onclick="toggleSearch()">
<span class="search-icon">
<i icon-name="search"></i>
</span>
<span class="search-text">
<span>Search</span>
<span style="font-size:.6rem;padding:2px 2px 0 6px;text-align:center;transform:translateY(4px)" class="search-keys">
CTRL + K
</span>
</span>
</div>
</nav>
<div class="search-container" id="globalsearch" onclick="toggleSearch()">
<div class="search-box">
<input type="search" id="term" placeholder="Start typing...">
<div id="search-results"></div>
<footer class="search-box-footer">
<div class="navigation-hint">
<span>Enter to select</span>
</div>
<div class="navigation-hint align-icon">
<i icon-name="arrow-up" aria-hidden="true"></i>
<i icon-name="arrow-down" aria-hidden="true"></i>
<span>to navigate</span>
</div>
<div class="navigation-hint">
<span>ESC to close</span>
</div>
</footer>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js"></script>
<script>document.addEventListener("DOMContentLoaded",init,!1),document.addEventListener("DOMContentLoaded",setCorrectShortcut,!1),window.toggleSearch=function(){document.getElementById("globalsearch").classList.contains("active")?document.getElementById("globalsearch").classList.remove("active"):(document.getElementById("globalsearch").classList.add("active"),document.getElementById("term").focus())},window.toggleTagSearch=function(e){console.log(e.textContent);const t=e.textContent;t&&(window.document.getElementById("term").value=t.trim(),window.toggleSearch(),window.search())};const loadingSvg='\n    <svg width="100" height="100" viewBox="0 0 45 45" xmlns="http://www.w3.org/2000/svg" stroke="#fff">\n      <g fill="none" fill-rule="evenodd" transform="translate(1 1)" stroke-width="2">\n          <circle cx="22" cy="22" r="6" stroke-opacity="0">\n              <animate attributeName="r"\n                   begin="1.5s" dur="3s"\n                   values="6;22"\n                   calcMode="linear"\n                   repeatCount="indefinite" />\n              <animate attributeName="stroke-opacity"\n                   begin="1.5s" dur="3s"\n                   values="1;0" calcMode="linear"\n                   repeatCount="indefinite" />\n              <animate attributeName="stroke-width"\n                   begin="1.5s" dur="3s"\n                   values="2;0" calcMode="linear"\n                   repeatCount="indefinite" />\n          </circle>\n          <circle cx="22" cy="22" r="6" stroke-opacity="0">\n              <animate attributeName="r"\n                   begin="3s" dur="3s"\n                   values="6;22"\n                   calcMode="linear"\n                   repeatCount="indefinite" />\n              <animate attributeName="stroke-opacity"\n                   begin="3s" dur="3s"\n                   values="1;0" calcMode="linear"\n                   repeatCount="indefinite" />\n              <animate attributeName="stroke-width"\n                   begin="3s" dur="3s"\n                   values="2;0" calcMode="linear"\n                   repeatCount="indefinite" />\n          </circle>\n          <circle cx="22" cy="22" r="8">\n              <animate attributeName="r"\n                   begin="0s" dur="1.5s"\n                   values="6;1;2;3;4;5;6"\n                   calcMode="linear"\n                   repeatCount="indefinite" />\n          </circle>\n      </g>\n  </svg>';function debounce(e,t,n){var a;return function(){var r=this,i=arguments,c=n&&!a;clearTimeout(a),a=setTimeout((function(){a=null,n||e.apply(r,i)}),t),c&&e.apply(r,i)}}function setCorrectShortcut(){navigator.platform.toUpperCase().indexOf("MAC")>=0&&document.querySelectorAll(".search-keys").forEach((e=>e.innerHTML="⌘ + K"))}function createIndex(e){const t=e=>e.toLowerCase().split(/([^a-z]|[^\x00-\x7F])/),n=new FlexSearch.Document({cache:!0,charset:"latin:extra",optimize:!0,index:[{field:"content",tokenize:"reverse",encode:t},{field:"title",tokenize:"forward",encode:t},{field:"tags",tokenize:"forward",encode:t}]});return e.forEach(((e,t)=>{n.add({id:t,title:e.title,content:e.content,tags:e.tags})})),n}async function init(){let e=!0;if(localStorage.getItem("searchIndex")){let{date:t,docs:n}=JSON.parse(localStorage.getItem("searchIndex"));if("2025-06-28T06:14:55.002Z"===t){e=!1;let t=createIndex(n);window.docs=n,window.index=t}}if(e){let e=await(await fetch("/searchIndex.json?v=2025-06-28T06:14:55.002Z")).json(),t=createIndex(e);localStorage.setItem("searchIndex",JSON.stringify({date:"2025-06-28T06:14:55.002Z",docs:e})),window.docs=e,window.index=t}document.addEventListener("keydown",(e=>{if((e.ctrlKey||e.metaKey)&&"k"===e.key&&(e.preventDefault(),toggleSearch()),"Escape"===e.key&&document.getElementById("globalsearch").classList.remove("active"),document.getElementById("globalsearch").classList.contains("active")){if("ArrowDown"===e.key){e.preventDefault();let t=document.querySelector(".searchresult.active");t?(t.classList.remove("active"),t.nextElementSibling?t.nextElementSibling.classList.add("active"):document.querySelector(".searchresult").classList.add("active")):document.querySelector(".searchresult").classList.add("active");let n=document.querySelector(".searchresult.active");n&&n.scrollIntoView({behavior:"smooth",block:"nearest",inline:"start"})}if("ArrowUp"===e.key){e.preventDefault();let t=document.querySelector(".searchresult.active");t?(t.classList.remove("active"),t.previousElementSibling?t.previousElementSibling.classList.add("active"):document.querySelectorAll(".searchresult").forEach((e=>{e.nextElementSibling||e.classList.add("active")}))):document.querySelectorAll(".searchresult").forEach((e=>{e.nextElementSibling&&e.classList.add("active")}));let n=document.querySelector(".searchresult.active");n&&n.scrollIntoView({behavior:"smooth",block:"nearest",inline:"start"})}if("Enter"===e.key){e.preventDefault();let t=document.querySelector(".searchresult.active");t&&(window.location.href=t.querySelector("a").href)}}}));const t=debounce(search,200,!1);field=document.querySelector("#term"),field.addEventListener("keydown",(e=>{"ArrowDown"!==e.key&&"ArrowUp"!==e.key&&t()})),resultsDiv=document.querySelector("#search-results");const n=new URL(location.href).searchParams;n.get("q")&&(field.setAttribute("value",n.get("q")),toggleSearch(),search())}async function search(){let e=field.value.trim();if(!e)return;if(e==lastSearch)return;console.log(`search for ${e}`),window.lastSearch=e,resultsDiv.innerHTML=loadingSvg;let t=offlineSearch(e),n="";if(!t.length){let t=document.createElement("p");return t.innerText=`No results for "${e}"`,resultsDiv.innerHTML="",void resultsDiv.appendChild(t)}n+='<div style="max-width:100%;">',t.forEach((e=>{e.tags&&e.tags.length>0?n+=`<div class="searchresult">\n                    <a class="search-link" href="${e.url}">${e.title}</a>\n                    <div onclick="window.location='${e.url}'">\n                        <div class="header-meta">\n                            <div class="header-tags">\n                                ${e.tags.map((e=>'<a class="tag" href="JavaScript:Void(0);">#'+e+"</a>")).join("")}\n                            </div>\n                        </div>\n                        ${e.content}\n                    </div>\n                </div>`:n+=`<div class="searchresult">\n                    <a class="search-link" href="${e.url}">${e.title}</a>\n                    <div onclick="window.location='${e.url}'">\n                        ${e.content}\n                    </div>\n                </div>`})),n+="</div>",resultsDiv.innerHTML=n}function truncate(e,t){return(e=e.replaceAll(/<[^>]*>/g,"")).length<t?e:e.substring(0,t-3)+"..."}function offlineSearch(e){let t=window.docs,n="#"===e[0]&&e.length>1?index.search(e.substring(1),[{field:"tags"}]):index.search(e,[{field:"title",limit:5},{field:"content",weight:10}]);const a=e=>{const t=n.filter((t=>t.field===e));return 0===t.length?[]:[...t[0].result]};return[...new Set([...a("title"),...a("content"),...a("tags")])].map((e=>{let n=t[e];return n.content=truncate(n.content,400),n.tags=n.tags.filter((e=>"gardenEntry"!=e&&"note"!=e)),n}))}window.lastSearch=""</script>
<main class="content cm-s-obsidian">
<header>
<h1 data-note-icon="">202308.综述：安卓恶意软件：Deep Learning for Android Malware Defenses：a Systematic Literature Review</h1>
<div class="header-meta">
<div class="header-tags">
</div>
<div class="timestamps"><div><i icon-name="calendar-plus"></i> <span class="human-date" data-date="2025-06-09T10:31:00.226+08:00"></span></div><div><i icon-name="calendar-clock"></i> <span class="human-date" data-date="2024-12-08T12:30:21.000+08:00"></span></div></div></div>
</header>
<p><a href="zotero://select/library/items/93YYBZZM" target="_blank" class="external-link">zotero库链接</a></p>
<h1 id="a-href-e7-bb-bc-e8-bf-b0-e7-bf-bb-e8-af-91-e5-ae-8-c-e6-95-b4-md-target-blank-class-external-link-a" tabindex="-1">更全面的翻译：<a href="%E7%BB%BC%E8%BF%B0%E7%BF%BB%E8%AF%91%E5%AE%8C%E6%95%B4.md" target="_blank" class="external-link">综述翻译完整</a></h1>
<p>↑：交写综述的作业用</p>
<p><a class="tag" onclick="toggleTagSearch(this)" data-content="#恶意软件检测">#恶意软件检测</a> <a class="tag" onclick="toggleTagSearch(this)" data-content="#综述">#综述</a> <a class="tag" onclick="toggleTagSearch(this)" data-content="#深度学习">#深度学习</a> <a class="tag" onclick="toggleTagSearch(this)" data-content="#安卓">#安卓</a><br>
老章发的安卓恶意代码综述</p>
<h1 id="名词解释" tabindex="-1">名词解释</h1>
<p>GPP：<a href="https://www.android.com/play-protect/" target="_blank" class="external-link">Google Play Protect</a><br>
APK：Android application package，<a href="android%E7%AC%94%E8%AE%B0%20%E5%AE%89%E5%8D%93.md" target="_blank" class="external-link">android笔记 安卓</a><br>
ML/DLbased malware detection：using machine learning/deep learning techniques to detect Android malware<br>
DL：Deep Learning</p>
<h1 id="摘要" tabindex="-1">摘要</h1>
<p>恶意应用程序（特别是针对 Android 平台的应用程序）对开发人员和最终用户构成严重威胁。大量的研究工作致力于开发有效的方法来防御 Android 恶意软件。然而，鉴于Android恶意软件的爆炸式增长以及混淆、反射等恶意规避技术的不断进步，基于手动规则或传统机器学习的Android恶意软件防御方法可能并不有效。近年来，深度学习（DL）这一主导研究领域提供了强大的特征抽象能力，在自然语言处理和计算机视觉等多个领域表现出了令人信服且有前途的性能。为此，利用深度学习技术来阻止 Android 恶意软件攻击最近引起了广泛的研究关注。然而，目前还没有针对 Android 恶意软件防御深度学习方法的系统文献综述。在本文中，我们进行了系统的文献综述，以搜索和分析深度学习方法如何应用于 Android 环境中的恶意软件防御。结果，共确定了 132 项涵盖 2014 年至 2021 年期间的研究。我们的调查显示，虽然这些来源中的大多数主要考虑基于深度学习的 Android 恶意软件检测，但 53 项初步研究 (40.1%) 设计了基于其他场景的防御方法。本综述还讨论了基于深度学习的 Android 恶意软件防御的研究趋势、研究重点、挑战和未来研究方向。</p>
<h1 id="1" tabindex="-1">1 介绍</h1>
<blockquote>
<p>Android恶意软件防御是计算机安全领域的一个重要研究课题。手动分析恶意软件，通过制定相应的规则，检查可疑Android应用程序的行为和源代码，是一个耗时的过程。它不能扩展到大量的Android软件。此外，随着恶意软件技术的不断发展，人工恶意软件分析已经跟不上攻击策略的发展。近年来，人们提出了大量与Android恶意软件自动分析相关的研究，利用数据挖掘和机器学习方法来实现可接受的恶意软件检测性能。这些方法采用一系列机器学习算法（如支持向量机、随机森林)，基于从Android应用程序包(APK)中提取的特征向量构建预测模型[^13,133,168]。然而，传统的机器学习算法在高维空间中学习复杂表征的能力有限<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。此外，机器学习模型的性能在很大程度上依赖于训练数据，随着Android应用的发展和软件工程的进步，这些训练过的模型很可能会过时。此外，攻击者不断更新他们的欺诈技术，以绕过保护软件和训练有素的机器学习模型，以伤害用户和企业。在Android恶意软件防御难度日益增加的情况下，仅通过传统的机器学习技术构建一个鲁棒透明的防御模型或系统并非易事<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。<br>
在过去十年中，深度学习已经成为机器学习的主要研究领域，在语音识别[^8,60]和图像处理[^142,173]等许多领域取得了显著成就。与传统的机器学习技术相比，当深度学习方法被输入原始数据时，特征提取可以自动执行。深度学习可以在不需要先验知识的情况下从输入的原始数据中学习特征表示，这是深度学习的关键优势。2014年，深度学习工具被应用于Android恶意软件防御，并表现出优异的性能<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。随后，越来越多的研究人员基于各种深度学习技术开发了Android恶意软件防御模型或框架。因此，迫切需要对基于dl的Android恶意软件防御进行最新的全面调查。</p>
<ul>
<li>本文的贡献
<ul>
<li>我们系统地收集和回顾了2014年至2021年间发表的132项基于DL的Android恶意软件防御的主要研究。</li>
<li>我们在收集研究的基础上提出了一个全面的定性和定量综合。</li>
<li>我们的综合涵盖以下主题:研究目标，APK表征，深度学习技术，部署和模型评估。我们进一步从不同方面列举了现有工作的当前问题，并根据研究结果提出建议，以支持该领域的进一步研究。</li>
<li>我们提供趋势分析，为研究界确定潜在的未来趋势。</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="2-review-methodology" tabindex="-1">2 综述方法 REVIEW METHODOLOGY</h1>
<h2 id="本文探讨的研究问题" tabindex="-1">本文探讨的研究问题</h2>
<ul>
<li>RQ1：基于dl的Android恶意软件防御解决方案的研究目标是什么？</li>
<li>RQ2：针对恶意软件防御开发了哪些方法？
<ul>
<li>RQ2.1：如何处理<strong>特征</strong>以进行模型训练？</li>
<li>RQ2.2：使用了哪些深度学习<strong>架构</strong>？</li>
<li>RQ2.3：基于dl的Android恶意软件防御方法在<strong>实践</strong>中是如何部署的？</li>
<li>RQ2.4：如何<strong>评估</strong>基于dl的Android恶意软件防御方法？</li>
</ul>
</li>
<li>RQ3：基于dl的Android恶意软件防御的新兴和潜在研究趋势是什么？</li>
</ul>
<h2 id="data-selection-process" tabindex="-1">数据选择过程 Data Selection Process</h2>
<p>![](/img/user/czc知识库/杂七杂八/9-附件/附件/Deep Learning for Android Malware Defenses： a Systematic Literature Review_image.png)</p>
<blockquote>
<p>结果表明，这些初级研究主要集中在顶级场馆，尤其是SEC域(如CCS、USENIX Security、TIFS等)的场馆以及越来越多的相关研究</p>
</blockquote>
<h1 id="3-results-analysis" tabindex="-1">3 结果分析 RESULTS ANALYSIS</h1>
<p>按研究目的对主要研究进行总结</p>
<h2 id="3-1-malware-defenses-objectives" tabindex="-1">3.1 恶意软件防御目标 Malware Defenses Objectives</h2>
<p>深度学习用于恶意软件防御的各个方面，这篇文章将调查的研究分为以下几类</p>
<ul>
<li>恶意软件检测(二进制分类) Malware Detection (Binary Classification)</li>
<li>恶意软件家族归属 Malware Family Attribution</li>
<li>重新包装/假冒应用程序检测 Repackaged/Fake App Detection</li>
<li>对抗性学习攻击和保护 Adversarial Learning Attacks and Protections</li>
<li>恶意软件进化检测和防御 Malware Evolution Detection and Defense</li>
<li>恶意行为分析 Malicious Behavior Analysis<br>
下图描述个来源研究目标统计数据![](/img/user/czc知识库/杂七杂八/9-附件/附件/Deep Learning for Android Malware Defenses： a Systematic Literature Review_image-2.png)</li>
</ul>
<h3 id="3-1-1" tabindex="-1">3.1.1 恶意软件检测(二进制分类)</h3>
<blockquote>
<p>如上图所示，恶意软件检测(二分类)，即判断一个给定的应用程序是恶意的还是良性的，受到了最多的研究关注( 68 % )，并且增长的趋势预计将继续。<br>
Droid-Sec<sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup>首次尝试使用基于深度学习的方法检测Android恶意软件。Droid-Sec的方法可以概括为三个步骤:(1)Android应用程序的收集和标记，(2)特征提取和表征，(3)深度学习模型的训练和评估。Droid-Sec的实证结果表明，与支持向量机(SVM)等传统机器学习技术相比，深度学习技术在恶意软件检测方面要有效得多。</p>
</blockquote>
<h3 id="3-1-2" tabindex="-1">3.1.2 恶意软件家族归属</h3>
<blockquote>
<p>图上显示，20篇被审查的文章(15%)专门用于识别Android恶意软件家族。<br>
于恶意软件变种的数量不断增加，恶意软件可以根据不同的恶意目的和行为被分类为特定的类别，比如向移动用户显示不想要的广告的Adware系列。（国内软件的环境不就是全是广告？）<br>
与恶意软件检测（二进制分类）相比，恶意软件家族归属识别恶意软件样本属于哪个家族。大多数初级研究，如<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>和<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>，采用多类分类方法来识别现有或旧的恶意软件家族。随着大量新的恶意软件变体的产生，Qiu等人<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>提出了基于深度学习的方法来检测零日恶意软件家族。</p>
</blockquote>
<h3 id="3-1-3" tabindex="-1">3.1.3 重新包装/假冒应用程序检测</h3>
<blockquote>
<p>在5%的来源中，研究了基于深度学习的重新包装/假应用检测。攻击者可以解包现有的恶意/良性应用程序，修改其内容并重新打包，从而剥夺应用程序开发人员的收入，并有助于恶意软件在移动设备上的传播<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>。由于这个原因，识别重新打包或伪造的应用程序并分析变体的行为也是至关重要的。例如，为了定位应用市场中的假冒移动应用，Ullah等人<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>和Karunanayake等人<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>提出了基于DL的假冒应用检测器，以防止在应用商店中发布假冒应用。</p>
</blockquote>
<h3 id="3-1-4" tabindex="-1">3.1.4 对抗性学习攻击和保护</h3>
<blockquote>
<p>上图显示，16个主要研究( 12 % )集中于对抗学习攻击和基于DL的恶意软件防御的保护。尽管大量的研究表明，深度学习模型在识别恶意软件方面具有很高的性能，但这些模型被证明特别容易受到精心设计的对抗性攻击[^82,183]。对抗攻击者可以注入一个小的但有意的扰动来创建对抗样本，导致训练好的模型对对抗样本进行错误分类。例如，Chen等人<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>对基于DNN的恶意软件检测模型进行对抗攻击，将准确率从90 %以上降低到0 %。因此，针对恶意软件防御模型的对抗攻击的注意力也相应增加，如图2所示。根据攻击发生的时间，将对抗攻击分为两大类：针对测试样本的逃避攻击和针对训练样本的中毒攻击。对于这两种类型的对抗攻击，(14项研究,占87%)的大部分来源讨论了基于DL的Android恶意软件防御模型的规避攻击和防护，相反，最近仅有两项研究关注了中毒攻击[^86,135]。我们在3.6.2节中详细讨论了这个问题。</p>
</blockquote>
<h3 id="3-1-5" tabindex="-1">3.1.5 恶意软件进化检测和防御</h3>
<blockquote>
<p>关于恶意软件演化问题，图2显示，仅有7篇论文( 5 % )试图开发恶意软件演化的解决方案，但值得注意的是，这7篇论文都是在最近3年内发表的。由于移动恶意软件的快速演化以及新变种和家族的出现，基于DL的恶意软件防御模型的性能随时间显著衰减。彭德尔伯里等人<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>揭示了基于深度学习的分类器对未来恶意软件样本的检测性能从几乎90 %急剧降低到30 %以下。因此，彭德尔伯里等人<sup class="footnote-ref"><a href="#fn11" id="fnref11:1">[11:1]</a></sup>将模型再训练和主动学习应用于老化模型的逆向和改进。然而，底层模型仍然无法通过这种方式区分演化的恶意软件，因为它们仍然依赖于人类来决定何时应该重新训练模型。针对这一问题，最近的研究[^37,85,89,174,178,187]引入了多种方法来减缓恶意软件防御模型的老化，这些方法将在3.6.3中进一步讨论。</p>
</blockquote>
<h3 id="3-1-6" tabindex="-1">3.1.6 恶意行为分析</h3>
<blockquote>
<p>在收集的研究中，与恶意行为分析相关的主要研究有6篇( 5 % )。恶意行为分析旨在识别或评估未知应用中的风险行为。对于Android恶意软件而言，恶意行为类型多样，一个恶意应用往往会执行多个恶意行为，增加了分析的难度。此外，恶意应用可能利用代码混淆和动态载荷来隐藏恶意行为。因此，对其进行研究是一个相对具有挑战性的研究课题。为了防止应用程序运行时的恶意活动，Gronat等人<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>和Lorenzo等人<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>使用循环神经网络来可视化Android恶意软件样本的潜在风险。对于Android恶意软件，执行恶意行为需要使用与用户隐私相关的权限和API调用等危险语义特征。为协助移动用户在安装未知应用或授予权限前确定安全风险，一些研究人员研究了风险权限和应用程序基于元数据特征之间的一致性，如描述[^39,42]或图标控件<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>。</p>
</blockquote>
<h3 id="讨论" tabindex="-1">讨论</h3>
<p>尽管针对Android恶意软件防御的深度学习研究越来越多，但之前的研究似乎都集中在相对简单的应用场景上。超过一半的源代码通过各种深度学习策略专注于恶意软件检测。此外，大多数现有研究都侧重于通过使用各种先进的深度学习技术来提高恶意软件检测性能，并证明新提出的模型在其自己的实验数据集上优于先前的模型。值得注意的是，最近越来越多的研究已经开始解决具体问题，以便在实践中更好地应用基于dl的恶意软件检测模型(例如，设备上的恶意软件检测[^40,41]，可解释的恶意软件检测[^167,197]，不平衡数据上的恶意软件检测[^16,112])。然而，相关研究的数量仍然很少。如何在深度学习的帮助下提高恶意软件检测器的鲁棒性有效性、稳定性和可靠性是未来研究人员的一个开放性问题。</p>
<h2 id="3-2-apk" tabindex="-1">3.2 APK特征</h2>
<h3 id="3-2-1" tabindex="-1">3.2.1 程序分析方法</h3>
<p>安卓恶意软件分析采用的方法分布![](/img/user/czc知识库/杂七杂八/9-附件/附件/Deep Learning for Android Malware Defenses： a Systematic Literature Review_image-3.png)</p>
<h4 id="静态分析：" tabindex="-1">静态分析：</h4>
<blockquote>
<p>大多数来源(73%)使用静态分析方法提取原始特征。逆向工程工具，如Androguard<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>和APKtool<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>需要反汇编和/或反编译AndroidAPK。从APK文件中提取的原始信息用于进一步分析恶意应用程序。提取的信息是多种多样的。原始二进制码和操作码序列可以直接馈送到深度学习模型[^59,66,141,196]。除此之外，API调用和权限等高级语义特性也被广泛使用[^54,77,140,188]。</p>
</blockquote>
<h4 id="动态分析：" tabindex="-1">动态分析：</h4>
<blockquote>
<p>只有17%的初步研究使用动态分析方法从AndroidAPK文件中收集原始特征。考虑到动态分析需要在受保护的环境中执行应用程序，而动态分析只能提供应用程序的部分图像（即，覆盖所有代码是具有挑战性的)，这一发现并不奇怪[^38,95]。然而，动态分析通过运行样本来检查Android应用程序的运行时行为和系统指标，这对混淆等恶意软件规避技术更具弹性<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>。代表性的动态分析工具有TaintDroid<sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>、CopperDroid<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>等。动态特性是通过在受控环境（如Android模拟器或真实的移动设备)中动态执行收集到的应用程序样本来获得的。13项初步研究使用仿真器(如Genymotion)来监控应用程序的动态行为。然而，各种反仿真器技术被开发来隐藏恶意活动。因此，我们还发现有7项主要研究集中在真实移动设备的动态分析上。例如，Alzaylaee等人<sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>证明，在稳定性和检测能力方面，设备上的动态分析比模拟器上的动态分析要好得多。</p>
</blockquote>
<h4 id="混合分析" tabindex="-1">混合分析</h4>
<blockquote>
<p>10%的初级研究涉及混合程序分析（静态和动态分析相结合）。静态程序分析的优点是以较低的计算成本提供完整的代码覆盖，但它容易受到混淆等逃避技术的攻击，而动态程序分析允许在受控环境中分析运行时行为，但代码覆盖可能有限[^23,154]。尽管混合分析利用两种程序分析的互补优势，它仍然是<strong>计算密集型</strong>的，这也许可以解释为什么相关研究的<strong>数量较少</strong>。</p>
</blockquote>
<h3 id="3-2-2" tabindex="-1">3.2.2 特征类别</h3>
<p>13类特征：![](/img/user/czc知识库/杂七杂八/9-附件/附件/Deep Learning for Android Malware Defenses： a Systematic Literature Review_image-4.png)</p>
<blockquote>
<p>语义特征是最常见的。API调用（55.3%)和权限（51.5%)是最常用的功能类型，占主要研究的一半以上。对此的一种可能解释是，API调用和权限带有足够的语义，而API调用和权限的风险通常会导致危险或恶意的行为。从反编译代码中提取的其他类型的语义信息，如过滤意图和应用程序组件，也被大量的初级研究使用。还有13项主要研究(10%)在分析Android恶意软件时使用程序图，如控制流图（CFG)和数据流图（DFG)来表示应用程序。除了从解压后的APK中提取的语义信息外，我们发现最近有8项研究利用了应用元数据，如图标和应用描述，用于后续分析。<br>
虽然上述特征通常是通过静态分析提取的，但我们发现了两个不同的动态特征。18项初步研究采用Linux内核系统调用作为提取特征来捕获恶意行为。与API调用不同，Linux内核系统调用不依赖于Android操作系统版本，这使得它们对恶意软件规避策略更具弹性<sup class="footnote-ref"><a href="#fn17" id="fnref17:1">[17:1]</a></sup>。此外，14项主要研究检查了与动态活动（如网络访问和内存转储)相关的特征。图4的这些观察结果证实了图3的观察结果，表明静态分析是程序分析中最常用的方法。<br>
尽管高级语义特征（如API调用）仍然是最常用的，但使用原始代码序列构建特征向量的初步研究越来越多。图4表明，最常见的原始代码特征是来自反汇编Android应用程序的原始操作码序列（共22项研究)。原始操作码序列被馈送到深度神经网络中，以自动学习高级语义特征表示<sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup>。注意，四个主要源代码将反汇编代码转换为Java源代码以构造特征向量。另一方面，我们发现13个初级研究用原始（raw）的class.dex字节码输入深度神经模型。例如，R2-D2 <sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup>通过将字节码的十六进制值映射到RGB颜色码，将字节码转换为彩色图像。</p>
</blockquote>
<h3 id="3-2-3" tabindex="-1">3.2.3 特征编码方法</h3>
<p>![](/img/user/czc知识库/杂七杂八/9-附件/附件/Deep Learning for Android Malware Defenses： a Systematic Literature Review_image-5.png)</p>
<blockquote>
<p>图5提供了一个基于特征编码方法的检查源的总结。在程序分析之后，将提取的信息进一步编码为特征向量，然后输入到深度学习模型中。在初级研究中，提取的特征有多种表示方法，因为从Android应用程序中提取的数据具有多种类别。因此，我们将特征编码方法分为以下5类：</p>
</blockquote>
<h4 id="分类编码" tabindex="-1">分类编码</h4>
<blockquote>
<p>图5表明，47%的来源（62项初步研究)最常使用分类编码方法。这个结果似乎与第3.2.2节一致，它表明像API调用和权限这样的分类语义特征是最常用的。通常，构造一个数值向量来表示每个分类特征的存在。值得注意的是，我们发现62个主要研究中有55个采用了单热编码来记录应用程序中每个可能的特征值的存在信息。例如，DroidDetector<sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup>通过混合分析总共考虑了192个特征，并为每个应用构建了一个192维向量，如果每个特征出现在应用中，则将其赋值为1；否则，它被赋值为0。此外，我们发现七个源为每个特征分配一个判别整数，并将使用的特征存储在数值向量中。尽管分类编码因其简单性而成为最流行的策略，但它有两个明显的缺点：(1)高维生成；(2)在不同模式之间的隔离嵌入<sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup>。</p>
</blockquote>
<h4 id="基于文本的编码" tabindex="-1">基于文本的编码</h4>
<blockquote>
<p>使用从自然语言处理到编码顺序特征的方法是很常见的。图5表明，26项初步研究(20%)尝试使用基于文本的特征编码方法。已经引入了许多最先进的文本编码方法来处理顺序数据。事实上，单热编码是最简单的文本编码方法，但其缺点之一是我们前面讨论过的高维问题。此外，一些研究人员还采用离散编码方法，如词袋(BOW)、词频-逆文档频率(TF-IDF)和N-Gram[^9,122,126,147,150,153,176,181]。然而，这些方法仍然受到数据稀疏性和高维问题的限制<sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup>。因此，许多初步研究进一步考察了预训练词嵌入模型的有效性，如Continuous Word2vec[^18,23,42,73,158,188,198]和GloVe<sup class="footnote-ref"><a href="#fn26" id="fnref26">[26]</a></sup>。</p>
</blockquote>
<h4 id="基于图的编码" tabindex="-1">基于图的编码</h4>
<blockquote>
<p>我们发现15项主要研究(11%)采用基于图的表示方法。Deep4MalDroid<sup class="footnote-ref"><a href="#fn17" id="fnref17:2">[17:2]</a></sup>通过动态分析工具获取系统调用，构造加权有向图，将每条边的权重、每个节点的入度和出度等图结构信息存储在向量中作为输入。Xu等<sup class="footnote-ref"><a href="#fn4" id="fnref4:1">[4:1]</a></sup>分别将CFG和DFG编码为邻接度量，并在嵌入层中合并为单个度量。在<sup class="footnote-ref"><a href="#fn27" id="fnref27">[27]</a></sup>中，作者研究了几种最先进的图嵌入方法来编码APl调用图，包括DeepWalk<sup class="footnote-ref"><a href="#fn28" id="fnref28">[28]</a></sup>，Node2vec<sup class="footnote-ref"><a href="#fn29" id="fnref29">[29]</a></sup>，HOPE<sup class="footnote-ref"><a href="#fn30" id="fnref30">[30]</a></sup>等。</p>
</blockquote>
<h4 id="基于图像的编码" tabindex="-1">基于图像的编码</h4>
<blockquote>
<p>基于图像的表示，在16个初步研究(12%)中使用，通常将提取的特征转换为灰度或彩色图像。最常见的场景是直接将字节码转换为图像。例如，IMCFN[151]将Android二进制读取为8位无符号整数的向量，然后将其转换为二维数组。接下来，Android字节码被可视化为基于RGB颜色映射的彩色图像。许多研究使用类似的方法对Android字节码进行编码[^19,59,66,107,130,141,171]。</p>
</blockquote>
<h4 id="混合编码" tabindex="-1">混合编码</h4>
<blockquote>
<p>在收集的研究中，结合不同的特征编码方法来处理更丰富的特征也很常见(6%)。以Kim等人[77]为例。作者构建了单热向量来记录权限、字符串和应用组件等分类特征的存在。同时，为了减轻混淆技术的影响，引I入了基于相似性的特征向量生成过程，对操作码和API调用等顺序特征进行编码。在[^74,116,170]中，由于这些研究也考虑了Android应用的图标或图片，因此采用图像嵌入方法和文本嵌入算法对特征进行编码。</p>
</blockquote>
<h3 id="讨论-1" tabindex="-1">讨论</h3>
<blockquote>
<p>根据我们的研究结果，大多数研究通过记录Android应用的各种分类特征的存在来构建特征向量。许多研究基于先验知识或特征选择方法创建一个查找表来列出所有潜在的特征，然后构建一个固定大小的单热特征向量来表示每个应用[^16,17,36,40,41,43,50,53,64,65,91,92,105,112,129,157,159,161,167,184,185]。例如，Wu等人<sup class="footnote-ref"><a href="#fn31" id="fnref31">[31]</a></sup>识别了158个高风险特征来构建特征向量（包括97个API调用和61个权限)。然而，以这种方式处理特性有几个问题。其中之一是，无论是使用人类经验还是传统的特征选择方法，都很难定义一个健壮的恶意特征列表。构建的特性列表不能包含所有潜在的恶意特征，导致实际应用中的性能不佳。即使使用训练数据中的所有特征，Android恶意软件进化导致的概念漂移也是一个不容忽视的严重问题<sup class="footnote-ref"><a href="#fn32" id="fnref32">[32]</a></sup>。Android恶意软件继续进化，具有类似的功能，但完全不同的实现，很容易躲过Android恶意软件防御模型的检测。因此，如何设计有效和实用的功能列表是一个具有挑战性的问题。<br>
如图3所示，静态程序分析是最常见的方法（73%)。此外，我们在第3.2.2节中的结果表明，大多数审查的研究从反汇编文件中提取静态语义特征。这种方法的一个显著缺点是处理混淆问题的能力较弱。混淆技术(例如，多态代码，加密)将恶意软件二进制文件转换为自压缩和独特结构的二进制文件，这些文件可以抵抗逆向工程方法[^47,113]。混淆技术提高了Android应用程序的代码保护，但对恶意软件分析造成了重大障碍。例如，代码重排序旨在修改小代码中指令的顺序，但保留原有的运行时执行轨迹，从而逃避恶意软件防御工具的检测<sup class="footnote-ref"><a href="#fn33" id="fnref33">[33]</a></sup>。通过使用各种混淆技术，恶意软件攻击者可以产生单个恶意样本的多个变体，从而使恶意软件防御复杂化。尽管一些研究表明，所提出的基于dl的方法受到一些简单混淆方法的轻微影响[^77,84,108,175]，但我们不能忽视这样一个事实，即现实世界的混淆技术不断更新和发展，以对抗恶意软件方法<sup class="footnote-ref"><a href="#fn21" id="fnref21:1">[21:1]</a></sup>。使用深度学习技术调查混淆应用程序是一个潜在的未来研究主题，我们概述了一些潜在的研究趋势：(1)使用深度学习技术检测和分析混淆方法；(2).基于字节码级别分析恶意软件，而不是捕获语义特征。</p>
</blockquote>
<h3 id="问题：如何处理特征以进行模型训练？" tabindex="-1">问题：如何处理特征以进行模型训练？</h3>
<ul>
<li>静态分析主要用于获取特性，静态语义特性（如API调用和权限)仍然是最常用的。</li>
<li>致力于动态分析的初步研究数量正在增加，并提出了许多普遍适用的方法/框架。</li>
<li>单热编码和文本编码主要用于表示特征。</li>
<li>13项主要研究将原始字节码编码为特征向量。</li>
</ul>
<h2 id="3-3-deep-learning-techniques" tabindex="-1">3.3 Deep Learning Techniques</h2>
<p>![](/img/user/czc知识库/杂七杂八/9-附件/附件/Deep Learning for Android Malware Defenses： a Systematic Literature Review_image-6.png)</p>
<h3 id="3-3-1-learning-paradigms" tabindex="-1">3.3.1 学习范式？（Learning paradigms）</h3>
<p>关于深度学习范例的类型，表 4 表明基于监督学习的 Android 恶意软件防御出现的频率最高 (81.8%)。值得注意的是，只有一个主要来源采用了无监督学习。具体来说，CADE [178] 提出了一种无监督表示学习方法来对抗安全应用的概念漂移。二十项主要研究 (15.2%) 开发了基于无监督和监督场景的 Android 恶意软件防御方法。具体来说，通常采用自动编码器等无监督 DNN 模型来初始化神经网络的权重。然后，可以使用标准监督反向传播算法使用标记样本对预训练模型进行微调 [33,43,49,63–65,76,101,139,140,​​157,159,161,176, 184、185、195、199]。此外，三项主要研究依靠强化学习来进行研究[129,156,190]。这些观察表明，需要足够标记数据的监督学习技术目前在该研究领域占据绝对主导地位。</p>
<h3 id="3-3-2-deep-learning-models" tabindex="-1">3.3.2 深度学习模型（Deep learning models）</h3>
<h4 id="ml-ps" tabindex="-1">多层感知器( MLPs )</h4>
<ul>
<li>也称为深度前馈网络或前馈神经网络，是用于Android恶意软件防御的最简单的深度学习模型之一。构建MLP是直接的，并且MLP可以学习输入的分层特征表示。MLPs被证明是通用的逼近器，能够将任意可测函数逼近到任意设计的精度<sup class="footnote-ref"><a href="#fn34" id="fnref34">[34]</a></sup>。因此，MLPs作为许多先进深度学习模型的基础，被广泛应用于各种研究领域<sup class="footnote-ref"><a href="#fn35" id="fnref35">[35]</a></sup>。</li>
</ul>
<h4 id="cn-ns-conv-nets" tabindex="-1">卷积神经网络( CNNs , ConvNets )</h4>
<p>通过引入卷积和池化(或下采样)操作来改进传统的多层感知器，从低模式中学习高层特征，具有更高的效率和准确性。因为与MLPs相比，CNNs可以自动学习Android应用程序的有用上下文结构信息。</p>
<h4 id="rn-ns" tabindex="-1">循环神经网络(RNNs)</h4>
<p>已经成为建模序列数据的成功范例，因为RNNs包含了隐含保持序列中所有过去元素历史的隐藏单元<sup class="footnote-ref"><a href="#fn36" id="fnref36">[36]</a></sup>。因此，它成为自然语言处理( NLP )和语音处理的有力工具<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>。Android应用程序的编程模式具有顺序性和逻辑性，从反编译代码中捕获顺序和语义属性对于提高恶意软件防御模型的性能至关重要。图6显示，17个主要研究( 12.9 % )使用RNN来防御Android恶意软件攻击。除了标准的RNN，高级变体如长短期记忆网络( Long Short Term Memory，<strong>LSTM</strong> )和门控循环单元( Gated Recurrent Unit，<strong>GRU</strong> )经常被用来克服梯度消失问题[^23, 29, 70, 153, 154, 172, 177, 193]</p>
<h4 id="a-es" tabindex="-1">自编码器( AEs )</h4>
<p>是一种无监督的神经网络，以无监督的方式学习输入的潜在空间。AEs已成功应用于降维和信息检索任务[^20、51]中。自动编码器的典型结构由两个部分组成：一个编码器将输入映射到一个隐藏表示，一个解码器将隐藏表示映射回去。AE及其变体，如降噪自动编码器( DAEs )和变分自编码器( VAEs )，已被广泛应用于Android恶意软件防御，涉及11个来源( 8.3 % )。</p>
<h4 id="deep-belief-networks-db-ns" tabindex="-1">深度信念网络( Deep Belief Networks，DBNs )</h4>
<p>属于概率生成模型，DBNs由多层随机隐变量分层构建[^61 ]。DBNs以无监督的方式从未标记的输入中学习多层特征，然后这些特征可以以监督的方式用于优化判别，从而执行分类任务。深度信念网络是最早成功接纳深度架构训练的非传统模型之一，但与其他先进的深度学习网络相比，目前很少被使用[^51 ]。图6显示了一致的结果，DBNs也是第一个构建Android恶意软件防御模型的DNN网络(深度神经网络)，在2014年至2016年间占比最高。</p>
<h4 id="generative-adversarial-networks-ga-ns" tabindex="-1">生成对抗网络(Generative Adversarial NetworksGANs)</h4>
<p>由生成模型和判别模型组成。生成器被训练用来生成新的样本以欺骗判别模型，而判别器则试图将生成的样本与真实的样本区分开来，就像猫和老鼠在博弈中互相竞争一样。GANs甚至在2016年被人工智能先驱杨立昆描述为近十年来最有趣的机器学习思想。尽管如此，<strong>仅有3项</strong>初步研究给出了基于GAN的Android恶意软件防御架构[^67、91、108]，表明GAN在恶意软件防御中的应用仍需进一步探索。</p>
<h4 id="graph-neural-networks-gn-ns" tabindex="-1">图神经网络( Graph Neural Networks，GNNs )</h4>
<p>是通过将深度学习技术扩展到图数据而设计的。人工智能研究者开发了多种GNN架构，如图卷积网络( Graph Convolutional Network，GCN ) [ 78 ]、图注意力网络( Graph Attention Network，GAT ) [ 152 ]等。在图6中，我们可以观察到最近的两项研究在Android恶意软件防御[ 37、48 ]中提出了基于GNNs的异构图表示学习方法。</p>
<h4 id="基于注意力机制的神经网络" tabindex="-1">基于注意力机制的神经网络</h4>
<p>能够学习输入和目标序列之间的依赖关系，为机器翻译带来了巨大的提升[^166 ]。因此，一个来源[^167 ]提出了一个可解释的基于注意力的Android恶意软件检测模型，因为注意力机制可以提供元素与其目标相关性的信息。尽管目前只有一项使用注意力机制的主要研究，但已经提出并证明了多种流行的注意力机制在NLP或CV中表现良好，如自注意力、软/硬注意力、局部和全局注意力、共同注意力等。因此，我们<strong>建议</strong>未来的研究人员做出更多的努力，<strong>将基于注意力的模型应用于Android恶意软件防御</strong>中的更多具体问题。</p>
<h4 id="deep-reinforcement-learning-drl" tabindex="-1">深度强化学习( Deep Reinforcement Learning，DRL )</h4>
<p>在试错法范式上运行，教会自主智能体如何在没有人为指导的情况下执行任务。DRL已经在游戏、机器人、自动驾驶汽车[^14、45 ]等领域展示了其显著的性能。在Android恶意软件防御中，我们还发现了3个基于DRL的初步研究[^17、129、190 ]。例如，Zhao等人[^190 ]和Rathore等人[^129 ]研究了强化学习对于规避对抗攻击的有效性以及相关的保护策略。</p>
<h4 id="transformers" tabindex="-1">Transformers</h4>
<p>Transformer通过利用自注意力机制，实现了比CNN和RNN更多的并行化。这种能力使得在GPU上高效(预)训练超大规模语言模型成为可能。来自Transformers的双向编码器表示( Bidirectional Encoder Representation from Transformers，BERT )是最广泛使用的基于Transformer的预训练语言模型之一[^30 ]。我们发现了一项研究，使用BRET对高度不平衡的恶意软件数据进行序列特征建模。</p>
<h4 id="基于混合的模型" tabindex="-1">基于混合的模型</h4>
<p>集成了几个基本的DNN模块，以形式化更鲁棒和更有效的模型。如图6所示，在11项主要研究( 8.3 % )中使用了基于混合的模型。已经考虑了许多深度学习框架组合，如AE和CNN [^72、159 ]，RNN和CNN [^116、118 ]，MLP和LSTM [^175 ]等。</p>
<h4 id="其他" tabindex="-1">其他</h4>
<p>近年来，深度学习发展迅速，新的深度学习技术不断被提出。两个来源利用了位于上述类别之外的深度学习模型。Bai等人[^16 ]通过孪生神经网络进行Android恶意软件家族分类。Ma等人[^103 ]采用深度残差学习来检测敏感行为。</p>
<h3 id="3-3-3-model-explanation" tabindex="-1">3.3.3 模型解释（Model explanation）</h3>
<p>深度学习模型的可解释性，现在有复杂结构的深度学习方法依旧是个黑盒，不能证明为什么一个样本被识别为恶意。实际恶意软件分析中最大的障碍是缺乏足够的透明性和可信度。，所以，这表明可解释的恶意软件防御深度学习方法</p>
<blockquote>
<p>在可解释性的范围方面，值得注意的是，大多数研究都采用了局部方法( 10项研究中有7项研究)。<strong>全局方法</strong>描述了特征如何平均影响预测，而<strong>局部方法</strong>旨在解释个体预测<sup class="footnote-ref"><a href="#fn37" id="fnref37">[37]</a></sup>。这些方法将目标分类器视为一个黑箱，通过使用一个简单的可解释模型来近似任何机器学习模型的决策边界。值得注意的是，两个主要研究采用基于梯度的解释方法(例如,积分梯度和Grad - CAM)，通过DNN反向传播梯度，以测量每个特征[^69、163 ]的敏感性。Wu等人[^167 ]利用定制的注意力机制设计了一种可解释的方法来对Android恶意软件进行分类。</p>
</blockquote>
<h3 id="讨论-2" tabindex="-1">讨论</h3>
<blockquote>
<ol>
<li>我们的研究结果表明，监督学习技术在当前的研究中占据着绝对的主导地位。然而，这种学习涉及数据标注，成本高昂且需要特定领域的知识。在Android恶意软件防御中，广泛使用<strong>VirusTotal</strong>等反病毒( Anti-Virus，AVs )技术为实验数据提供真值。我们不能忽视以下几个重大问题。首先，使用AVs来区分恶意软件和良性应用程序可能是很方便的。然而，<strong>AVs无法执行复杂的标注任务</strong>，如演化的恶意软件标注或恶意软件行为标注，<strong>仍然需要大量的专业知识</strong>。其次，大多数AVs工作在签名，启发式和基于行为的检测引擎上[^180 ]。然而，这些方法仍然是<strong>耗时的和依赖于人的</strong>，更严重的问题是它们<strong>不能在未来的样本上很好地工作</strong>[^180 ]。此外，随着时间的推移，一个商业AVs可能会产生不一致的结果，或者不同的AVs可能会产生不同的结果，从而导致真实值不可靠[^22 ]。因此，针对Android恶意软件防御的可靠数据标注可能是一个潜在的研究课题。我们也鼓励我们的研究人员更多地关注需要较少的人力来标注数据的深度学习技术，如主动学习、半监督学习、强化学习或无监督学习。</li>
<li>综述的大多数研究都与深度学习有关，但是大多数都只是用了三到四层神经网络。使用小规模的数据训练很深的神经网络会导致严重的过拟合<sup class="footnote-ref"><a href="#fn35" id="fnref35:1">[35:1]</a></sup>，虽然浅层的DNN网络在Android恶意软件防御中表现出了良好的性能，但更深层的神经网络在该领域值得进一步探索。另一方面，在大量数据上训练的<strong>预训练模型</strong>在CV和NLP领域发挥着重要作用，因为它们降低了将这些DNN模型应用于现实世界问题的障碍。随着Android恶意软件数量的爆炸式增长，似乎每次需要一个模型时，从头开始训练一个DNN模型并不是一个好的解决方案。针对Android恶意软件的预训练DL模型可以为该领域的研究带来极大的便利。</li>
<li>随着Android应用的指数级增长，为达到期望的性能，对海量计算资源的需求正成为该领域日益关注的问题。与文本和图像相比，Android文件体积更大，结构更复杂，需要借助逆向工程工具进行特征处理，耗时较长。此外，目前的深度学习框架涉及相当数量的计算资源，以接近最先进的性能[^125 ]。因此，<strong>提高</strong>基于DL的Android恶意软件防御方法的<strong>计算效率</strong>是一个越来越迫切的需求。<br>
目前的研究主要集中在从APK中提取简单的基于语义特征的特征，因此更丰富的特征类型和更深入的源代码解释有待进一步研究。具体来说，深度学习技术已被广泛用于分析原始代码，但如何将不可读代码转换为语义解释是一个尚未解决的问题。另一方面，目前还没有一个有效的可解释Android恶意软件防御的评估系统，这使得研究人员很难衡量解释结果的质量和比较可选择的解释方法。事实上，对于有经验的恶意软件分析人员来说，几乎不可能在不出错的情况下检测出恶意软件样本中的所有恶意行为。因此，提高对恶意软件样本解释的可靠性是未来研究者面临的潜在挑战。</li>
</ol>
</blockquote>
<h3 id="2-2" tabindex="-1">问题2.2：使用了哪些深度学习架构?</h3>
<p>•MLPs、CNNs和RNNs多用于Android恶意软件防御；<br>
•研究主要集中在监督学习任务，特别是二分类任务；<br>
•最近先进的深度学习技术(例如, GAN , attention和DRL)在Android恶意软件防御中的应用还比较初步；<br>
•对基于可解释深度学习的恶意软件防御的兴趣增加，从2019年开始已经发表了10项相关研究。</p>
<h2 id="3-4" tabindex="-1">3.4 分析的部署</h2>
<p>针对恶意软件防御的部署方法可以分为三类：( i )off-device、( ii )On-device和( iii )分布式，即( i )和( ii )的组合[^38 ]。<br>
![](/img/user/czc知识库/杂七杂八/9-附件/附件/Deep Learning for Android Malware Defenses： a Systematic Literature Review_image-7.png)</p>
<blockquote>
<p>在93.2 %的信源中，所提出的工具部署在设备外(见表6)。具体来说，大多数研究设计了一种非设备的方法，并在个人计算机或更高性能的GPU服务器上进行实验。在大量数据上进行自动化的恶意软件防御需要大量的计算资源。因此，大多数来源<strong>并没有考虑将获得的DL模型部署在移动设备上以便实际使用</strong>。<br>
相反，只有两项研究提出了[^40、41 ]的On-device方法。设备上Android恶意软件防御通过移动设备本身提供分析结果，而不需要共享或上传隐私数据。目前，基于深度学习技术的设备上Android恶意软件防御框架通常通过将服务器上训练好的模型移植到智能手机上实现。Feng等人[^40、41 ]提出了两个设备上的Android恶意软件检测系统MobiDroid和MobiTive，它们利用深度学习技术在用户的移动设备上提供实时检测。<br>
我们还发现了7个分布式方法( 5.3 % ) [^4、50、66、147、150、156、179]。分布式恶意软件防御，在移动设备上执行实时分析或检测，同时在远程服务器上执行详细和计算昂贵的分析[^38 ]。一个很好的例子是<strong>Hsien等人[^66 ]提出的R2 - D2</strong>，其中Android用户在自己的移动设备上扫描一个可疑的应用程序，如果该应用程序之前未被识别，则将该应用程序的class.dex转换成需要上传至服务器端的RGB图像。在他们的后端服务器中，图像将被输入到一个CNN网络中，一旦被识别，结果将被发送到用户的手机。其中一个主要的缺点是，分布式方法将重要的私有数据透露给云，因为通过互联网的上传过程和分析服务器本身可能不安全。在机器学习领域，G â lvez等[^46 ]利用半监督集成学习实现了一个隐私保护的恶意软件检测器。然而，基于分布式DL的方法的隐私保护仍然需要深入研究。<br>
在评论这些发现时，我们将鼓励作者提出更多的On-device和分布式恶意软件防御方法。此外，我们将鼓励未来的作者研究现实世界问题的可能解决方案，如<strong>隐私保护和计算资源限制</strong>。</p>
</blockquote>
<h3 id="讨论-3" tabindex="-1">讨论</h3>
<p>大多数研究都是off-device的。他们首先收集了大量的恶意软件样本，并在个人计算机或GPU服务器上进行模型训练和模型评估，这是深度学习应用领域相当普遍的操作。然而，随着恶意软件技术的发展和更新，模型老化问题不可避免，导致性能随时间显著下降。当报告一个新的Android恶意软件家族时，这些过时的模型在响应时间内更新它是相对困难的。此外，设备外分析无法为移动用户提供及时的保护。分布式或设备上的Android恶意软件是潜在的解决方案之一，但目前相关的研究数量相对较少。此外，先前的方法还存在一些缺陷。<br>
现有的针对Android恶意软件防御的分布式/设备上框架非常简单和有限。首先，可疑的Android应用必须<strong>上传到服务器端，这需要很高的通信开销</strong>。将部分计算任务分配给智能手机是一个潜在的选项。但是，在检测性能和实时性需求之间寻求折衷是一个挑战。另一方面，客户端和服务器之间通过互联网进行<strong>通信的过程可能不够安全</strong>。对于攻击者来说，修改上传数据或者窃取隐私数据并不是一件困难的事情。因此，在未来的工作中，考虑隐私保护是必要的。毫无疑问，随着深度学习技术和智能手机的快速发展，将会有新的可用的DNN架构支持在移动设备上有效工作。因此，我们希望未来的研究人员能够提出<strong>更实用的设备上</strong>方法。</p>
<h2 id="3-5" tabindex="-1">3.5 性能评估</h2>
<h4 id="3-5-1" tabindex="-1">3.5.1 数据集</h4>
<p>首先，我们对收集到的研究中使用的实验数据集进行了检验。图7表明，作者可以从多种来源收集恶意软件和固件样本。<br>
![](/img/user/czc知识库/杂七杂八/9-附件/附件/Deep Learning for Android Malware Defenses： a Systematic Literature Review_image-8.png)<br>
关于好的软件样本，官方的Google Play Store是最常用的，有37.1%。值得注意的是，诸如安智、华为应用商店和APKPure等第三方市场也是真实世界Android样本的流行来源。相反，Drebin [^13 ]，AMD [^165 ]和Genome [^194 ]等公开的研究数据集更容易收集恶意应用。值得注意的是，有61项初步研究收集了来自Drebin的恶意软件样本( 46.2 % )。<strong>一个潜在的缺点是这些数据集在发布后没有进行维护或更新，导致收集的样本过时。</strong> 以Drebin为例，该数据集包括2011年至2014年的123，453个良性样本和5，560个恶意软件样本。尽管这些数据集被广泛使用，但评估结果似乎并不能反映最近恶意软件样本的真实检测能力。为了克服这种限制，图7显示，作者对Andro Zoo [^10 ]和Virus Share [^155 ]等在线存储库越来越感兴趣，以收集最近的恶意样本。<br>
![](/img/user/czc知识库/杂七杂八/9-附件/附件/Deep Learning for Android Malware Defenses： a Systematic Literature Review_image-9.png)<br>
其次，对于评估数据的规模，图8 ( a )表示评估数据数量的分布，而图8 ( b )显示了良性样本与恶意软件样本规模之比的分布。性能评估使用的Goodware样本中位数为9945，性能评估使用的恶意软件样本中位数为7149 (见图8 ( a )) )。图8 ( b )显示，19个初级研究的goodware：恶意软件率设置为1:1，构建了一个平衡的数据集。彭德尔伯里等人[^119 ]描述了现实世界中好软件的数量远大于恶意软件的数量，<strong>Android恶意软件占所有应用程序的6 %到18.6 %之间</strong>。然而，似乎只有7个来源( 5 &lt; a &lt; = 10 )和6个来源( a &gt; 10 )似乎坚持了一个现实的设置，即软件和恶意软件的比例。甚至有28项初步研究构建了包含更多恶意软件样本的评估数据集。彭德尔伯里等人[^119 ]证实了关于软件和恶意软件比例的不切实际的假设会导致性能有偏。因此，我们鼓励作者<strong>在适当和可靠的环境下构建评估数据</strong>。</p>
<h3 id="3-5-2" tabindex="-1">3.5.2 评估方法</h3>
<p>![](/img/user/czc知识库/杂七杂八/9-附件/附件/Deep Learning for Android Malware Defenses： a Systematic Literature Review_image-10.png)</p>
<blockquote>
<p>图9总结了所审查的研究中使用的评估方法。其中，59篇( 44.6 % )采用k折交叉验证（k-fold cross-validation），44篇( 33.3 % )采用留一法验证（holdout validation）。由于恶意软件的演化，14项主要研究( 10.6 % )基于时间戳拆分评估数据（split evaluation data based on timestamps），以便进行时间感知实验。为了比较性能，我们可以看到67个来源( 50.7 % )与Drebin [^13 ]和MaMaDroid [^104 ]等传统机器学习方法进行了性能比较，而44个来源( 33.3 % )与其他基于深度学习的方法进行了性能比较。有趣的是，有7项主要研究( 5.3 % )将所提出的方法与非学习工具(如基于签名的反病毒扫描仪)进行了比较。<br>
值得注意的是，有36个来源(27.2%)对深度学习模型中的超参数(例如，学习率和隐藏层大小)的影响进行了评估。只有7个初级研究进行了案例研究，对具体结果进行了深入的人工分析。为了证明所提出方法的稳健性，一些研究还检查了它们对混淆(7.5%)和对抗性攻击(12.8%)的弹性。为了证明所提出方法的可靠性，14项主要研究(10.6%)列出了最重要的特征，以衡量不同特征对预测的贡献。此外，我们发现有11个来源(8.3%)在现实场景中进行了评估测试，以进一步证明性能。</p>
</blockquote>
<h3 id="3-5-3-evaluation-metrics" tabindex="-1">3.5.3 评价指标（Evaluation metrics）</h3>
<p>先前的研究结果表明，大多数研究都集中在一个分类问题上。因此，在大多数收集的研究中，来自传统分类问题的评估指标被直接用于衡量所提出的恶意软件防御模型的性能。在[^99、127 ]中详细讨论了这些标准分类评价指标( (例如,准确率,精确率,召回率, F1分数,真阳性率,假阳性率,受试者工作特征( ROC ))曲线)。计算效率是综述性论文中另一个常用的衡量标准。具体来说，时间成本如特征处理时间和硬件资源消耗如内存使用通常被考虑。<br>
为了确定这些基于深度学习的方法的有效性，我们还研究了评估指标的具体值。由于准确率和F1分数是最常出现的( 71.2 %的信息源使用准确率, 43.1 %的信息源使用F1分数)，我们记录了在评论来源中呈现的最高准确率和F1分数值。图10给出了它们的分布。值得注意的是，准确率/ F1的中位数为98 %。此外，25 %的源的准确率/ F1值大于99 %。大量研究[^12、119 ]指出，大多数研究由于<strong>一系列有偏的实验设置而导致了过于乐观的结果</strong>（例如：数据不平衡，数据过时）。然而，这一问题仍需在未来进行深入研究。关于影响评估绩效的潜在风险/偏差的更多信息，请参考Arp等[^12 ]的实证研究。</p>
<h3 id="3-5-4" tabindex="-1">3.5.4 有效性</h3>
<p>对收集到的研究中提出的工作的可用性进行了调查，这有助于未来的研究人员对提出的工具进行测量和认证。表7给出了可公开使用的工具汇总。在综述来源中，仅有30篇初级研究提供了公开可用的工具，仅占22.7 %。在公开的方法中，有26种方法是开源的。值得注意的是，在这30个来源中，有26个来自2019年至2021年，这表明基于DL的Android恶意软件防御的研究社区对分享他们的研究努力表现出越来越大的兴趣。<br>
![](/img/user/czc知识库/杂七杂八/9-附件/附件/Deep Learning for Android Malware Defenses： a Systematic Literature Review_image-11.png)</p>
<h3 id="讨论-4" tabindex="-1">讨论</h3>
<p>第一个问题是评价结果可能不能反映模型的真实表现。例如，将Drebin和Contagio等很久以前发布的恶意软件数据集与来自官方Android市场的最新良性样本相结合来构建新的实验训练数据[^9、29、31、108]是相当普遍的。这些恶意软件数据集没有实时更新以包含最新的恶意软件样本，从而包含过时的恶意软件样本。另一方面，随着防御策略的演变，一些用于公共数据集的恶意技术很可能会被抛弃。使用这些类型的数据训练的模型在处理最近的恶意应用程序方面相当薄弱。<br>
数据分布高度不平衡，给恶意软件分析带来了一系列挑战。首先，在现实场景中，良性样本的数量远远大于恶意软件样本的数量，但这一事实通常被先前的研究人员所忽视<sup class="footnote-ref"><a href="#fn11" id="fnref11:2">[11:2]</a></sup>。同样，不同恶意软件家族或恶意软件类别的样本数量也有很大差异。以Drebin数据集为例，虽然其5560个恶意软件样本可以分为179个不同的家族，但只有33个家族包含超过15个样本。因此，小规模的恶意软件家族很容易被错误地分类到训练数据集的主导家族类别中。Bai等人<sup class="footnote-ref"><a href="#fn38" id="fnref38">[38]</a></sup>表明，尽管许多提出的方法已被证明具有良好的性能和较高的准确性，但这些模型在预测小家庭时表现不佳，即使使用了降采样方法。因此，我们建议在分析恶意软件时考虑数据不平衡对于开发更实用的恶意软件防御方法至关重要。<br>
另一个重要的问题是有限的可重复性。我们的综述结果表明，<strong>只有少量的初级研究共享其源代码</strong>，这使得未来研究人员对评估结果的验证更加困难。除源代码外，大多数研究从多种来源收集评估数据，但缺乏对收集数据的更多细节描述。Daoudi等人[^26 ]尝试复现了5个基于ML的Android恶意软件检测器，但只有一个是成功的。因此，为未来的研究者提供一个透明的绩效评价管理框架是必要的。</p>
<h2 id="3-6" tabindex="-1">3.6 分析趋势</h2>
<p>![](/img/user/czc知识库/杂七杂八/9-附件/附件/Deep Learning for Android Malware Defenses： a Systematic Literature Review_image-12.png)</p>
<h3 id="3-6-1" tabindex="-1">3.6.1 统计分析</h3>
<p>从表8中可以看出，将深度学习技术集成到恶意软件检测中仍然是( 10个来源中,有7个)的主要关注点。但具体而言，这些研究使用各种深度学习模型(例如, MLP、CNN、DBN等。)来检测恶意应用。值得注意的是，Grosse等人[^54 ]的被引次数最多，并且高被引次数的原因之一是这项工作调查了对抗神经网络的对抗攻击技术在该领域的可行性，这为未来的工作奠定了基础。2019年发表的另一篇研究恶意软件演化的工作[^119 ]也是一篇高被引论文。这些事实表明，基于DL的检测模型的鲁棒性正吸引着越来越多的研究关注。<br>
虽然根据引文对这些初级研究进行分类可以帮助我们识别高影响的工作，但由于时间的延迟，不适用于最近的工作。因此，我们列出了在CORE排名系统中质量排名最高(A*)的顶级场馆近期发表的所有论文（2019－2021年)，如表9所示，可以帮助我们了解顶级研究人员当前的研究重点。值得注意的是，顶级机构，特别是在安全领域（CCS和USENIXsecurity)，发表了越来越多的相关研究。虽然本表所列的论文大部分仍集中在恶意软件检测方面，但他们对Android恶意软件检测中更具体的问题进行了更深入的分析，如评估指标、数据不平衡问题、可解释性、模型老化等。同样值得注意的是，“对抗性学习攻击与保护”和“恶意软件进化检测与防御”最近频繁出现在顶级场所。这两个问题与所提出的架构的实用性和有效性密切相关，它们属于未来研究的关键领域，以提高Android恶意软件防御的最新水平。<br>
表8和表9进一步总结了这些研究中使用的深度学习架构。从图6可以看出，近年来CNN、RNN和MLP在Android恶意软件防御中得到了广泛的应用，其中MLP在列出的重要作品中出现频率最高。这一结果并不令人意外。MLP是最简单但又最典型的深度神经网络，因此研究人员在有新的研究思路时往往会首先基于MLP网络进行实验。与表8中列出的来源相比，最近的研究采用了更先进的深度学习模型，如基于注意力的网络和GNN。这些观察结果也表明，先进的深度学习技术在Android恶意软件防御领域的应用实际上处于初级阶段。近年来，深度学习在许多领域取得了令人瞩目的进展，许多现代深度学习方法应运而生，如深度主动学习、强化学习、迁移学习、可控生成模型等。然而，深度学习技术在移动安全领域的应用远远落后于深度学习本身的发展。针对基于dl的Android恶意软件防御的研究目前处于活跃状态，因此我们相信在不久的将来会有更多的进展。</p>
<h3 id="3-6-2" tabindex="-1">3.6.2对抗学习攻击与防护</h3>
<p>深度学习模型对对抗攻击不具有抵抗力，会导致模型输出完全错误的预测。仅对原始样本施加微小但有意的扰动即可生成对抗样本。关于对抗样本制作技术和防御技术的详细分类可以在这些调查工作[ 2、115 ]中找到。如前所述，我们发现了16项( 12 % )与对抗学习攻击和保护有关的初步研究。表10是对这16项主要研究的详细总结。<br>
针对对抗性攻击的目标阶段，规避攻击显然受到了更多的研究关注，占87.5%。逃避攻击在推理时修改数据点，导致错误分类。例如，Grosse等人[54]对基于dnn的恶意软件检测模型进行了对抗性规避攻击。本工作利用基于雅可比矩阵的白盒攻击[115]生成对抗性示例，评估结果表明，规避算法可以对Drebin上63%的恶意软件样本进行错误分类。相反，只有两项初步研究[86，135]调查了投毒攻击，其中对手的目标是使模型训练过程受害。有趣的是，这两个来源都致力于后门投毒攻击。<br>
表10显示了五个主要针对白盒攻击的源。白盒攻击假定攻击者具有关于训练模型的知识，例如模型体系结构和超参数。例如，GrOSSe等人[54]需要DNN网络的梯度信息来制作对抗性示例。有五个来源对基于d的恶意软件检测模型执行黑盒攻击，攻击者不需要了解目标分类器。六项初步研究还评估了DNN模型在黑盒和白盒场景下的鲁棒性。这些研究表明，当攻击者对模型体系结构的了解有限时，攻击者更容易受到攻击。<br>
对抗性防御策略方面，表10表明，75%的源采用对抗性攻击的防御机制。值得一提的是，大多数研究应用对抗性训练和集成学习来防御对抗性攻击[54,87,88,123,172,190]。</p>
<h3 id="3-6-3" tabindex="-1">3.6.3恶意软件演化检测与防御</h3>
<p>在安全领域，恶意软件进化有几个类似的概念，如概念漂移[178]、时间衰减[119]和模型老化[187]。图2显示了最近发现的七个用于检测和防御恶意软件演变的源。为了更好地了解目前的研究状况，表11对这七项主要研究进行了总结。值得强调的是，有四项初步研究[37，85，174,187]试图捕捉特征的语义相似性以减缓模型老化。Pendlebury等人[119]提出了一种时间感知性能指标，用于测量分类器对恶意软件进化的弹性。实际上，这些方法仅仅减缓了由恶意软件演化引起的模型性能下降。因此，模型再训练或主动学习等模型更新方法也经常被研究，以逆转和改进过时的模型[119,187]。然而，这种模型更新方法仍然是进化不敏感的，需要定期再训练。此外，这个过程往往需要大量的努力标记新的样品。为此，Yang等人在更新老化模型之前使用对比学习来识别和理解漂移恶意软件样本。</p>
<h3 id="问题：新兴和潜在的研究趋势是什么?" tabindex="-1">问题：新兴和潜在的研究趋势是什么?</h3>
<p>虽然已有很多基于dl的Android恶意软件防御的研究，但这个课题还需要更深入的分析。恶意软件的进化和对抗性攻击是近年来的两个热门话题。如何提高基于dll的Android恶意软件防御框架的可靠性、鲁棒性和实用性是未来的挑战。</p>
<h1 id="4" tabindex="-1">4 开放性问题及未来趋势</h1>
<p>在这项工作中，我们在第3节总结了基于DL的Android恶意软件防御的相关来源，并从各个方面讨论了研究趋势和挑战。在这里，我们借鉴这项系统综述的这些发现，为未来的研究人员提供一组围绕Android安全的研究和实践的讨论点。<br>
<strong>Android恶意软件防御仍然是一个有待进一步研究的热门话题。</strong><br>
正如我们的系统回顾所揭示的那样，近年来有很多研究致力于基于dl的Android恶意软件防御，并且相关研究的数量正在不断增加。这表明，移动安全是当今人们关注的主要问题。手机已经成为人们日常生活中不可缺少的一部分，移动用户对私人移动安全的关注也大大增加，尤其是对恶意应用的防范。然而，现有的研究大多将恶意软件检测作为一种二元分类问题进行研究，远远不足以解决当前的问题，提高移动安全水平。恶意软件仍然是网络空间中最有效的威胁之一，恶意软件编写者不断更新恶意软件技术以绕过安全检测。因此，这项研究需要更深入的分析，而不是简单地寻找一个二进制标签。其他研究方面，如恶意软件归因/行为、恶意软件变体、恶意软件分类和感染治疗，仍然很少受到关注。<br>
<strong>数据不平衡。</strong><br>
正如第3.5 . 1节所示，出于性能评估的目的，源代码更倾向于构造一个相对平衡的数据集。然而，Android恶意软件防御存在严重的样本稀疏性和不平衡性问题。在Android景观中，固件的数量明显大于恶意软件的数量[ 119 ]。此外，恶意软件家族的(在一些家庭中有成千上万的样本,而在另一些家庭中只有少数)也是高度不平衡的。许多先前的研究表明，不平衡的数据分布阻碍了[ 16、119 ]的性能。因此，如何针对基于DL的Android恶意软件防御中的数据不平衡问题开发有效的解决方案引起了广泛的研究兴趣。从我们的综述结果中，我们确定了两个处理数据不平衡问题的相关研究，包括基于Siamese网络的不平衡家族分类方法[ 16 ]和基于BERT的不平衡恶意软件检测方法<sup class="footnote-ref"><a href="#fn39" id="fnref39">[39]</a></sup>。然而，这两项研究仅限于相对简单的场景，仍需要更多的努力来克服数据不平衡对Android恶意软件防御的负面影响。<br>
<strong>提高实用性和可靠性是重中之重</strong>。<br>
我们的研究还发现，提高基于dl的Android恶意软件防御方法的实用性和可靠性引起了越来越多的研究兴趣。尽管在一系列的研究实验中，先进的深度学习技术已经被证明在防御恶意软件攻击方面是有效的，但如何在实践中有效地应用这些方法仍然没有解决。未来的研究不仅应该找到克服移动计算资源限制的解决方案来部署基于dl的恶意软件防御体系结构，而且还应该提出一个全面的框架来应对许多现实挑战，如互联网隐私保护和信息更新，这可能需要网络安全和计算机互联网其他特定领域的知识。除此之外，深度神经网络的黑箱性质对在实践中实施这些提出的方法构成了严重的障碍。如何提高恶意软件防御过程的透明度，将是未来值得关注的研究课题。<br>
<strong>深度学习在Android安全领域仍处于早期阶段。</strong><br>
与其他研究领域相比，Android安全社区对深度学习的研究似乎相对单一。首先，有监督的DNN是研究最多的，这些研究通常在其提出的架构中考虑三到四层的DNN。其次，更高级的深度学习方法，如强化学习和在线学习，只有少数论文涉及。第三，之前的大部分工作在一些简单的任务上采用了深度学习技术，比如二进制Android恶意软件分类。事实上，深度学习在计算机视觉和自然语言处理方面已经取得了相当大的成就。这些先进的技术已经被证明在解决许多复杂任务方面具有强大的能力[83]。例如，Wu等人[167]引l入了一种注意力机制来提高Android恶意软件检测模型的可解释性。因此，它有望应用先进的深度学习技术来帮助我们解决Android安全中更复杂和具体的问题。与此同时，虽然监督学习在Android安全领域占主导地位，但标记数据非常耗时，需要大量的专业知识。正如Lecun等人的深度学习教科书[83]所描述的那样，无监督学习属于深度学习的未来。我们鼓励我们的研究人员在Android安全领域的无监督深度学习方面做出更多的努力，以便在未来取得更大的进步。<br>
<strong>APK嵌入是一个重要但尚未触及的话题。</strong><br>
与图像或文字信息不同，Android应用程序是由多个复杂数据组成的。Android APK是一个由多个文件组成的压缩档案。通过逆向工程，可以提取权限、操作码等各种类型的特性，进行进一步分析。事实上，深度学习仍在努力对这些复杂的数据模态进行建模[125]。因此，现有的研究要么将APK转化为单一类型的特征，要么设计多模型深度学习架构来处理它们。为了获得与深度学习模型兼容的形式化表示，引入了CV和NLP的嵌入技术来编码特征，但这些技术对于具有复杂结构的APK文件可能相对较浅。对于Android安全性，对于DNN模型的“APK嵌入”的探索还有很长的路要走。</p>
<h1 id="5-threats-to-validity" tabindex="-1">5 THREATS TO VALIDITY</h1>
<p>尽管这个系统性的综述是按照一个成熟的方法进行的<sup class="footnote-ref"><a href="#fn40" id="fnref40">[40]</a></sup>，但我们不能保证我们的研究涵盖了所有相关的研究，因为综述过程中的一些限制。因此，本节描述了可能对我们实证研究的有效性造成的威胁。<br>
<strong>搜索项目和策略</strong>。一个主要的潜在威胁是相关的出版物收集偏见。为了定位相关研究，我们在2.2节中描述了一个搜索字符串和搜索数据库列表。搜索字符串由来自软件工程和人工智能领域的不同项目制定。虽然我们为搜索项添加了替代拼写和同义词，但我们可能仍然会遗漏一些搜索项。例如，深度学习是一个快速发展的研究领域，A科学家将在短时间内继续提出新的深度学习技术；因此，识别所有相关的DL项目是一个挑战。为了尽量减少这个问题，我们保留了AI专家调查的[51，83，134]中描述的DL项目。在确定了搜索字符串之后，我们使用了5个知名的电子数据库来收集相关研究。我们还在两个流行的研究引文引擎上进行了进一步的搜索过程，并进行了向后滚雪球，以覆盖最广泛意义上的相关出版物。<br>
<strong>数据选择偏差</strong>(Data selectionbias)。出版物的选择仅由一名研究人员进行，这可能会导致研究缺失。尽管如此，所有作者共同制定了合适的研究选择方案，其他三位作者在整个审稿过程中给予了有效而详细的反馈，并密切监控审稿执行情况。另一方面，为了减少质量评价过程中主观因素的影响，引入了场馆h5指数作为质量评价标准。虽然h5值可能会随着时间的推移而变化，但顶级场馆有影响力的论文被保证纳入考虑范围。</p>
<h1 id="6" tabindex="-1">6 结论</h1>
<p>本文深入研究了在Android恶意软件防御中使用深度学习。此外，该研究还讨论了使用深度学习的Android恶意软件防御相关的研究目标、特征、方法和挑战。我们收集了132项相关研究。我们审查的结果表明，深度学习技术正在成为防御Android恶意应用程序的强大而有前途的工具。我们发现：(1)大多数研究都是为了检测恶意软件而进行的，但对恶意应用程序的其他类型更详细的分析正受到越来越多的关注；(2)静态程序分析被广泛用于收集特征，语义特征频繁出现;(3)各种DNN架构被用于分析恶意软件，其中mlp和cnn的应用最为广泛;(4)大多数方法是作为监督分类任务执行的;(5)分布式分析和设备上分析逐渐受到重视;(6)对抗性学习和恶意软件进化是最近的两个热门话题。</p>
<h1 id="references" tabindex="-1">REFERENCES</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Yann LeCun, Yoshua Bengio, and Geoffrey Hinton. 2015. Deep learning. nature 521, 7553 (2015), 436–444. <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Yanjie Zhao, Li Li, Haoyu Wang, Haipeng Cai, Tegawendé F Bissyandé, Jacques Klein, and John Grundy. 2021. On the impact of sample duplication in machine-learning-based android malware detection. ACM Transactions on Software Engineering and Methodology (TOSEM) 30, 3 (2021), 1–38. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Zhenlong Yuan, Yongqiang Lu, Zhaoguo Wang, and Yibo Xue. 2014. Droid-sec: deep learning in android malware detection. In Proceedings of the 2014 ACM conference on SIGCOMM. 371–372. <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>XU Zhiwu, Kerong Ren, and Fu Song. 2019. Android malware family classification and characterization using CFG and DFG. In 2019 International Symposium on Theoretical Aspects of Software Engineering (TASE). IEEE, 49–56. <a href="#fnref4" class="footnote-backref">↩︎</a> <a href="#fnref4:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Yuxia Sun, Yanjia Chen, Yuchang Pan, and Lingyu Wu. 2019. Android Malware Family Classification Based on Deep Learning of Code Images. IAENG International Journal of Computer Science 46, 4 (2019). <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Junyang Qiu, Jun Zhang, Wei Luo, Lei Pan, Surya Nepal, Yu Wang, and Yang Xiang. 2019. A3CM: automatic capability annotation for android malware. IEEE Access 7 (2019), 147156–147168. <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Li Li, Tegawendé F Bissyandé, and Jacques Klein. 2019. Rebooting research on detecting repackaged android apps: Literature review and benchmark. IEEE Transactions on Software Engineering 47, 4 (2019), 676–693. <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Farhan Ullah, Hamad Naeem, Muhammad Rashid Naeem, Sohail Jabbar, Shehazad Khalid, Fadi Al-Turjman, and Abdelrahman Abuarqoub. 2019. Detection of clone scammers in Android markets using IoT-based edge computing. Transactions on Emerging Telecommunications Technologies (2019), e3791. <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Naveen Karunanayake, Jathushan Rajasegaran, Ashanie Gunathillake, Suranga Seneviratne, and Guillaume Jourjon. 2020. A Multi-modal Neural Embeddings Approach for Detecting Mobile Counterfeit Apps: A Case Study on Google Play Store. IEEE Transactions on Mobile Computing (2020), 1–1. <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Xiao Chen, Chaoran Li, Derui Wang, Sheng Wen, Jun Zhang, Surya Nepal, Yang Xiang, and Kui Ren. 2019. Android HIV: A study of repackaging malware for evading machine-learning detection. IEEE Transactions on Information Forensics and Security 15 (2019), 987–1001. <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Feargus Pendlebury, Fabio Pierazzi, Roberto Jordaney, Johannes Kinder, and Lorenzo Cavallaro. 2019. {TESSERACT}: Eliminating experimental bias in malware classification across space and time. In 28th {USENIX} Security Symposium ({USENIX} Security 19). 729–746. <a href="#fnref11" class="footnote-backref">↩︎</a> <a href="#fnref11:1" class="footnote-backref">↩︎</a> <a href="#fnref11:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Petr Gronát, Javier Alejandro Aldana-Iuit, and Martin Bálek. 2019. MaxNet: Neural Network Architecture for Continuous Detection of Malicious Activity. In 2019 IEEE Security and Privacy Workshops (SPW). IEEE, 28–35. <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>Andrea De Lorenzo, Fabio Martinelli, Eric Medvet, Francesco Mercaldo, and Antonella Santone. 2020. Visualizing the outcome of dynamic analysis of Android malware with VizMal. Journal of Information Security and Applications 50 (2020), 102423. <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>Shengqu Xi, Shao Yang, Xusheng Xiao, Yuan Yao, Yayuan Xiong, Fengyuan Xu, Haoyu Wang, Peng Gao, Zhuotao Liu, Feng Xu, et al. 2019. DeepIntent: Deep icon-behavior learning for detecting intention-behavior discrepancy in mobile apps. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security. 2421–2436. <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>BlackHat 2011. Androguard. Retrieved Oct 25, 2021 from <a href="https://code.google.com/archive/p/androguard" target="_blank" class="external-link">https://code.google.com/archive/p/androguard</a> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Apktool 2010. APKTOOL. Retrieved Oct 25, 2021 from <a href="https://ibotpeaches.github.io/Apktool/" target="_blank" class="external-link">https://ibotpeaches.github.io/Apktool/</a> <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Shifu Hou, Aaron Saas, Lifei Chen, and Yanfang Ye. 2016. Deep4maldroid: A deep learning framework for android malware detection based on linux kernel system call graphs. In 2016 IEEE/WIC/ACM International Conference on Web Intelligence Workshops (WIW). IEEE, 104–111. <a href="#fnref17" class="footnote-backref">↩︎</a> <a href="#fnref17:1" class="footnote-backref">↩︎</a> <a href="#fnref17:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>William Enck, Peter Gilbert, Seungyeop Han, Vasant Tendulkar, Byung-Gon Chun, Landon P Cox, Jaeyeon Jung, Patrick McDaniel, and Anmol N Sheth. 2014. Taintdroid: an information-flow tracking system for realtime privacy monitoring on smartphones. ACM Transactions on Computer Systems (TOCS) 32, 2 (2014), 1–29. <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Kimberly Tam, Salahuddin J Khan, Aristide Fattori, and Lorenzo Cavallaro. 2015. Copperdroid: automatic reconstruction of android malware behaviors.. In Ndss. <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>Mohammed K Alzaylaee, Suleiman Y Yerima, and Sakir Sezer. 2017. Emulator vs real phone: Android malware detection using machine learning. In Proceedings of the 3rd ACM on International Workshop on Security and Privacy Analytics. 65–72. <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>Junyang Qiu, Jun Zhang, Wei Luo, Lei Pan, Surya Nepal, and Yang Xiang. 2020. A survey of Android malware detection with deep neural models. ACM Computing Surveys (CSUR) 53, 6 (2020), 1–36. <a href="#fnref21" class="footnote-backref">↩︎</a> <a href="#fnref21:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>Na Huang, Ming Xu, Ning Zheng, Tong Qiao, and Kim-Kwang Raymond Choo. 2019. Deep Android Malware Classification with API-Based Feature Graph. In 2019 18th IEEE International Conference On Trust, Security And Privacy In Computing And Communications/13th IEEE International Conference On Big Data Science And Engineering (TrustCom/BigDataSE). IEEE, 296–303. <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>Zhenlong Yuan, Yongqiang Lu, and Yibo Xue. 2016. Droiddetector: android malware characterization and detection using deep learning. Tsinghua Science and Technology 21, 1 (2016), 114–123. <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>Yang Li and Tao Yang. 2018. Word embedding for understanding natural language: a survey. In Guide to Big Data Applications. Springer, 83–104. <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>Yuxuan Wang, Yutai Hou, Wanxiang Che, and Ting Liu. 2020. From static to dynamic word representations: a survey. International Journal of Machine Learning and Cybernetics (2020), 1–20. <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>ElMouatez Billah Karbab, Mourad Debbabi, Abdelouahid Derhab, and Djedjiga Mouheb. 2018. MalDozer: Automatic framework for android malware detection using deep learning. Digital Investigation 24 (2018), S48–S59. <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>Abdurrahman Pektaş and Tankut Acarman. 2020. Deep learning for effective Android malware detection using API call graph embeddings. Soft Computing 24, 2 (2020), 1027–1043. <a href="#fnref27" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>Bryan Perozzi, Rami Al-Rfou, and Steven Skiena. 2014. Deepwalk: Online learning of social representations. In Proceedings of the 20th ACM SIGKDD international conference on Knowledge discovery and data mining. 701–710. <a href="#fnref28" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p>Aditya Grover and Jure Leskovec. 2016. node2vec: Scalable feature learning for networks. In Proceedings of the 22nd ACM SIGKDD international conference on Knowledge discovery and data mining. 855–864. <a href="#fnref29" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn30" class="footnote-item"><p>Mingdong Ou, Peng Cui, Jian Pei, Ziwei Zhang, and Wenwu Zhu. 2016. Asymmetric transitivity preserving graph embedding. In Proceedings of the 22nd ACM SIGKDD international conference on Knowledge discovery and data mining. 1105–1114. <a href="#fnref30" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn31" class="footnote-item"><p>Bozhi Wu, Sen Chen, Cuiyun Gao, Lingling Fan, Yang Liu, Weiping Wen, and Michael R Lyu. 2021. Why an Android App Is Classified as Malware: Toward Malware Classification Interpretation. ACM Transactions on Software Engineering and Methodology (TOSEM) 30, 2 (2021), 1–29. <a href="#fnref31" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn32" class="footnote-item"><p>Xiaohan Zhang, Yuan Zhang, Ming Zhong, Daizong Ding, Yinzhi Cao, Yukun Zhang, Mi Zhang, and Min Yang. 2020. Enhancing State-of-the-art Classifiers with API Semantics to Detect Evolved Android Malware. In Proceedings of the 2020 ACM SIGSAC Conference on Computer and Communications Security. 757–770. <a href="#fnref32" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn33" class="footnote-item"><p>Alessandro Bacci, Alberto Bartoli, Fabio Martinelli, Eric Medvet, and Francesco Mercaldo. 2018. Detection of obfuscation techniques in Android applications. In Proceedings of the 13th International Conference on Availability, Reliability and Security. 1–9. <a href="#fnref33" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn34" class="footnote-item"><p>Kurt Hornik, Maxwell Stinchcombe, and Halbert White. 1989. Multilayer feedforward networks are universal approximators. Neural networks 2, 5 (1989), 359–366. <a href="#fnref34" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn35" class="footnote-item"><p>Ian Goodfellow, Yoshua Bengio, and Aaron Courville. 2016. Deep learning. MIT press. <a href="#fnref35" class="footnote-backref">↩︎</a> <a href="#fnref35:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn36" class="footnote-item"><p>Jeffrey L Elman. 1990. Finding structure in time. Cognitive science 14, 2 (1990), 179–211. <a href="#fnref36" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn37" class="footnote-item"><p>Christoph Molnar. 2020. Interpretable machine learning. Lulu. com. <a href="#fnref37" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn38" class="footnote-item"><p>Yude Bai, Zhenchang Xing, Xiaohong Li, Zhiyong Feng, and Duoyuan Ma. 2020. Unsuccessful story about few shot malware family classification and siamese network to the rescue. In Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering. 1560–1571. <a href="#fnref38" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn39" class="footnote-item"><p>Rajvardhan Oak, Min Du, David Yan, Harshvardhan Takawale, and Idan Amit. 2019. Malware Detection on Highly Imbalanced Data through Sequence Modeling. In Proceedings of the 12th ACM Workshop on Artificial Intelligence and Security. 37–48. <a href="#fnref39" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn40" class="footnote-item"><p>Barbara Kitchenham. 2004. Procedures for performing systematic reviews. Keele, UK, Keele University 33, 2004 (2004), 1–26. <a href="#fnref40" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</main>
<aside>
<div class="sidebar">
<div class="sidebar-container">
<div class="toc">
<div class="toc-title-container">
<div class="toc-title">
On this page
</div>
</div>
<div class="toc-container">
<nav class="toc">
<ol>
<li><a href="#a-href-e7-bb-bc-e8-bf-b0-e7-bf-bb-e8-af-91-e5-ae-8-c-e6-95-b4-md-target-blank-class-external-link-a">更全面的翻译：综述翻译完整</a>
</li>
<li><a href="#名词解释">名词解释</a>
</li>
<li><a href="#摘要">摘要</a>
</li>
<li><a href="#1">1 介绍</a>
</li>
<li><a href="#2-review-methodology">2 综述方法 REVIEW METHODOLOGY</a>
<ol>
<li><a href="#本文探讨的研究问题">本文探讨的研究问题</a>
</li>
<li><a href="#data-selection-process">数据选择过程 Data Selection Process</a>
</li>
</ol>
</li>
<li><a href="#3-results-analysis">3 结果分析 RESULTS ANALYSIS</a>
<ol>
<li><a href="#3-1-malware-defenses-objectives">3.1 恶意软件防御目标 Malware Defenses Objectives</a>
<ol>
<li><a href="#3-1-1">3.1.1 恶意软件检测(二进制分类)</a>
</li>
<li><a href="#3-1-2">3.1.2 恶意软件家族归属</a>
</li>
<li><a href="#3-1-3">3.1.3 重新包装/假冒应用程序检测</a>
</li>
<li><a href="#3-1-4">3.1.4 对抗性学习攻击和保护</a>
</li>
<li><a href="#3-1-5">3.1.5 恶意软件进化检测和防御</a>
</li>
<li><a href="#3-1-6">3.1.6 恶意行为分析</a>
</li>
<li><a href="#讨论">讨论</a>
</li>
</ol>
</li>
<li><a href="#3-2-apk">3.2 APK特征</a>
<ol>
<li><a href="#3-2-1">3.2.1 程序分析方法</a>
<ol>
<li><a href="#静态分析：">静态分析：</a>
</li>
<li><a href="#动态分析：">动态分析：</a>
</li>
<li><a href="#混合分析">混合分析</a>
</li>
</ol>
</li>
<li><a href="#3-2-2">3.2.2 特征类别</a>
</li>
<li><a href="#3-2-3">3.2.3 特征编码方法</a>
<ol>
<li><a href="#分类编码">分类编码</a>
</li>
<li><a href="#基于文本的编码">基于文本的编码</a>
</li>
<li><a href="#基于图的编码">基于图的编码</a>
</li>
<li><a href="#基于图像的编码">基于图像的编码</a>
</li>
<li><a href="#混合编码">混合编码</a>
</li>
</ol>
</li>
<li><a href="#讨论-1">讨论</a>
</li>
<li><a href="#问题：如何处理特征以进行模型训练？">问题：如何处理特征以进行模型训练？</a>
</li>
</ol>
</li>
<li><a href="#3-3-deep-learning-techniques">3.3 Deep Learning Techniques</a>
<ol>
<li><a href="#3-3-1-learning-paradigms">3.3.1 学习范式？（Learning paradigms）</a>
</li>
<li><a href="#3-3-2-deep-learning-models">3.3.2 深度学习模型（Deep learning models）</a>
<ol>
<li><a href="#ml-ps">多层感知器( MLPs )</a>
</li>
<li><a href="#cn-ns-conv-nets">卷积神经网络( CNNs , ConvNets )</a>
</li>
<li><a href="#rn-ns">循环神经网络(RNNs)</a>
</li>
<li><a href="#a-es">自编码器( AEs )</a>
</li>
<li><a href="#deep-belief-networks-db-ns">深度信念网络( Deep Belief Networks，DBNs )</a>
</li>
<li><a href="#generative-adversarial-networks-ga-ns">生成对抗网络(Generative Adversarial NetworksGANs)</a>
</li>
<li><a href="#graph-neural-networks-gn-ns">图神经网络( Graph Neural Networks，GNNs )</a>
</li>
<li><a href="#基于注意力机制的神经网络">基于注意力机制的神经网络</a>
</li>
<li><a href="#deep-reinforcement-learning-drl">深度强化学习( Deep Reinforcement Learning，DRL )</a>
</li>
<li><a href="#transformers">Transformers</a>
</li>
<li><a href="#基于混合的模型">基于混合的模型</a>
</li>
<li><a href="#其他">其他</a>
</li>
</ol>
</li>
<li><a href="#3-3-3-model-explanation">3.3.3 模型解释（Model explanation）</a>
</li>
<li><a href="#讨论-2">讨论</a>
</li>
<li><a href="#2-2">问题2.2：使用了哪些深度学习架构?</a>
</li>
</ol>
</li>
<li><a href="#3-4">3.4 分析的部署</a>
<ol>
<li><a href="#讨论-3">讨论</a>
</li>
</ol>
</li>
<li><a href="#3-5">3.5 性能评估</a>
<ol>
<li><a href="#3-5-1">3.5.1 数据集</a>
</li>
<li><a href="#3-5-2">3.5.2 评估方法</a>
</li>
<li><a href="#3-5-3-evaluation-metrics">3.5.3 评价指标（Evaluation metrics）</a>
</li>
<li><a href="#3-5-4">3.5.4 有效性</a>
</li>
<li><a href="#讨论-4">讨论</a>
</li>
</ol>
</li>
<li><a href="#3-6">3.6 分析趋势</a>
<ol>
<li><a href="#3-6-1">3.6.1 统计分析</a>
</li>
<li><a href="#3-6-2">3.6.2对抗学习攻击与防护</a>
</li>
<li><a href="#3-6-3">3.6.3恶意软件演化检测与防御</a>
</li>
<li><a href="#问题：新兴和潜在的研究趋势是什么?">问题：新兴和潜在的研究趋势是什么?</a>
</li>
</ol>
</li>
</ol>
</li>
<li><a href="#4">4 开放性问题及未来趋势</a>
</li>
<li><a href="#5-threats-to-validity">5 THREATS TO VALIDITY</a>
</li>
<li><a href="#6">6 结论</a>
</li>
<li><a href="#references">REFERENCES</a>
</li>
</ol>
</nav>
</div>
</div>
<div class="backlinks">
<div class="backlink-title" style="margin:4px 0!important">Pages mentioning this page</div>
<div class="backlink-list"><div class="backlink-card"><i icon-name="link"></i><a href="/硕士研究生/科研/恶意软件检测文献阅读/恶意软件检测文献阅读/" data-note-icon="" class="backlink">恶意软件检测文献阅读</a>
</div></div>
</div>
</div>
</div>
</aside>
<style>#tooltip-wrapper{background:var(--background-primary);padding:1em;border-radius:4px;overflow:hidden;position:fixed;width:80%;max-width:400px;height:auto;max-height:300px;font-size:.8em;box-shadow:0 5px 10px rgba(0,0,0,.1);opacity:0;transition:opacity .1s;unicode-bidi:plaintext;overflow-y:scroll;z-index:10}#tooltip-wrapper:after{content:"";position:absolute;z-index:1;bottom:0;left:0;pointer-events:none;width:100%;unicode-bidi:plaintext;height:75px}</style>
<div style="opacity:0;display:none" id="tooltip-wrapper">
<div id="tooltip-content">
</div>
</div>
<iframe style="display:none;height:0;width:0" id="link-preview-iframe" src="">
</iframe>
<script>var opacityTimeout,contentTimeout,transitionDurationMs=100,iframe=document.getElementById("link-preview-iframe"),tooltipWrapper=document.getElementById("tooltip-wrapper"),tooltipContent=document.getElementById("tooltip-content"),linkHistories={};function hideTooltip(){opacityTimeout=setTimeout((function(){tooltipWrapper.style.opacity=0,contentTimeout=setTimeout((function(){tooltipContent.innerHTML="",tooltipWrapper.style.display="none"}),transitionDurationMs+1)}),transitionDurationMs)}function showTooltip(t){var e=t.target,o=e.getClientRects()[e.getClientRects().length-1],i=window.pageYOffset||document.documentElement.scrollTop,n=t.target.getAttribute("href");if(-1===n.indexOf("http")||-1!==n.indexOf(window.location.host)){let t=n.split("#")[0];linkHistories[t]?(tooltipContent.innerHTML=linkHistories[t],tooltipWrapper.style.display="block",setTimeout((function(){if(tooltipWrapper.style.opacity=1,-1!=n.indexOf("#")){let t=n.split("#")[1];const e=tooltipWrapper.querySelector(`[id='${t}']`);e.classList.add("referred"),e.scrollIntoView({behavior:"smooth"},!0)}else tooltipWrapper.scroll(0,0)}),1)):(iframe.src=t,iframe.onload=function(){tooltipContentHtml="",tooltipContentHtml+='<div style="font-weight: bold; unicode-bidi: plaintext;">'+iframe.contentWindow.document.querySelector("h1").innerHTML+"</div>",tooltipContentHtml+=iframe.contentWindow.document.querySelector(".content").innerHTML,tooltipContent.innerHTML=tooltipContentHtml,linkHistories[t]=tooltipContentHtml,tooltipWrapper.style.display="block",tooltipWrapper.scrollTop=0,setTimeout((function(){if(tooltipWrapper.style.opacity=1,-1!=n.indexOf("#")){let t=n.split("#")[1];const e=tooltipWrapper.querySelector(`[id='${t}']`);e.classList.add("referred"),console.log(e),e.scrollIntoView({behavior:"smooth"},!0)}else tooltipWrapper.scroll(0,0)}),1)}),tooltipWrapper.style.left=o.left-tooltipWrapper.offsetWidth/2+o.width/2+"px",window.innerHeight-o.top<tooltipWrapper.offsetHeight?tooltipWrapper.style.top=o.top+i-tooltipWrapper.offsetHeight-10+"px":window.innerHeight-o.top>tooltipWrapper.offsetHeight&&(tooltipWrapper.style.top=o.top+i+35+"px"),o.left+o.width/2<tooltipWrapper.offsetWidth/2?tooltipWrapper.style.left="10px":document.body.clientWidth-o.left-o.width/2<tooltipWrapper.offsetWidth/2&&(tooltipWrapper.style.left=document.body.clientWidth-tooltipWrapper.offsetWidth-20+"px")}}function setupListeners(t){t.addEventListener("mouseleave",(function(t){hideTooltip()})),tooltipWrapper.addEventListener("mouseleave",(function(t){hideTooltip()})),t.addEventListener("mouseenter",(function(t){clearTimeout(opacityTimeout),clearTimeout(contentTimeout),showTooltip(t)})),tooltipWrapper.addEventListener("mouseenter",(function(t){clearTimeout(opacityTimeout),clearTimeout(contentTimeout)}))}window.addEventListener("load",(function(t){document.querySelectorAll(".internal-link").forEach(setupListeners),document.querySelectorAll(".backlink-card a").forEach(setupListeners)}))</script>
<script>window.location.hash&&document.getElementById(window.location.hash.slice(1)).classList.add("referred"),window.addEventListener("hashchange",(e=>{const t=e.oldURL.split("#");t[1]&&document.getElementById(t[1]).classList.remove("referred");const n=e.newURL.split("#");n[1]&&document.getElementById(n[1]).classList.add("referred")}),!1);const url_parts=window.location.href.split("#"),url=url_parts[0],referrence=url_parts[1];document.querySelectorAll(".cm-s-obsidian > *[id]").forEach((function(e){e.ondblclick=function(e){const t=url+"#"+e.target.id;navigator.clipboard.writeText(t)}}))</script>
<script src="https://fastly.jsdelivr.net/npm/luxon@3.2.1/build/global/luxon.min.js"></script>
<script defer="defer">TIMESTAMP_FORMAT="MMM dd, yyyy h:mm a",document.querySelectorAll(".human-date").forEach((function(e){date=e.getAttribute("data-date")||e.innerText,parsed_date=luxon.DateTime.fromISO(date),null!=parsed_date.invalid&&(parsed_date=luxon.DateTime.fromSQL(date)),null!=parsed_date.invalid&&(parsed_date=luxon.DateTime.fromHTML(date)),e.innerHTML=parsed_date.toFormat(TIMESTAMP_FORMAT)}))</script>
<script>lucide.createIcons({attrs:{class:["svg-icon"]}})</script>
</body>
</html>
