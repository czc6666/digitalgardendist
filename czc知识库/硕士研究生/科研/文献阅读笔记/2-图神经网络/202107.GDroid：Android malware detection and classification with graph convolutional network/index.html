<!doctype html>
<html lang="en">
<head>
<title>202107.GDroid：Android malware detection and classification with graph convolutional network</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<script async type="module">import mermaid from"https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs"</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-sv0slik/5O0JIPdLBCR2A3XDg/1U3WuDEheZfI/DI5n8Yqc3h5kjrnr46FGBNiUAJF7rE4LHKwQ/SoSLRKAxEA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script async src="https://cdn.jsdelivr.net/npm/lucide@0.115.0/dist/umd/lucide.min.js"></script>
<script>window.addEventListener("load",(()=>{document.querySelectorAll(".callout").forEach((e=>{const t=getComputedStyle(e).getPropertyValue("--callout-icon"),l=t&&t.trim().replace(/^lucide-/,"");if(l){const t=e.querySelector(".callout-title");if(t){const e=document.createElement("div"),c=document.createElement("i");e.appendChild(c),c.setAttribute("icon-name",l),e.setAttribute("class","callout-icon"),t.insertBefore(e,t.firstChild)}}})),lucide.createIcons(),Array.from(document.querySelectorAll(".callout.is-collapsible")).forEach((e=>{e.querySelector(".callout-title").addEventListener("click",(t=>{e.classList.contains("is-collapsed")?e.classList.remove("is-collapsed"):e.classList.add("is-collapsed")}))}))}))</script>
<script async src="https://fastly.jsdelivr.net/npm/force-graph@1.43.0/dist/force-graph.min.js"></script>
<script async src="https://fastly.jsdelivr.net/npm/@alpinejs/persist@3.11.1/dist/cdn.min.js"></script>
<script src="https://fastly.jsdelivr.net/npm/alpinejs@3.11.1/dist/cdn.min.js" async></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-okaidia.min.css" integrity="sha512-mIs9kKbaw6JZFfSuo+MovjU+Ntggfoj8RwAmJbVXQ5mkAX5LlgETQEweFPI18humSPHymTb5iikEOKWF7I8ncQ==" crossorigin="anonymous" referrerpolicy="no-referrer" async>
<script src="https://fastly.jsdelivr.net/npm/whatwg-fetch@3.6.2/dist/fetch.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer" async></script>
<link href="/styles/digital-garden-base.css" rel="stylesheet">
<link href="/styles/obsidian-base.css" rel="stylesheet">
<link href="/styles/_theme.d92311c2.css" rel="stylesheet">
<link href="/styles/custom-style.css" rel="stylesheet">
<link rel="icon" href="/favicon.ico" sizes="any">
<link rel="icon" href="/favicon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="manifest" href="/manifest.webmanifest">
<style></style>
</head>
<body class="theme-dark markdown-preview-view markdown-rendered markdown-preview-section">
<nav class="navbar">
<div class="navbar-inner">
<a href="/" style="text-decoration:none">
<h1 style="margin:15px!important">Digital Garden</h1>
</a>
</div>
</nav>
<main class="content cm-s-obsidian">
<header>
<div class="header-meta">
</div>
</header>
<p>pdf链接：<a href="GDroid_2021_Gao%20et%20al.pdf" target="_blank" class="external-link">GDroid_2021_Gao et al</a><br>
<a href="zotero://select/library/items/SVXCMVT7" target="_blank" class="external-link">zotero库链接</a></p>
<h1 id="摘要" tabindex="-1">摘要</h1>
<p>恶意软件数量的急剧增加给Android平台带来了严峻的挑战，给恶意软件分析带来了困难。在本文中，我们提出了一种基于图卷积网络（GCN）的 Android 恶意软件检测和家族分类的新方法。总体思路是<strong>将应用程序和 Android API 映射到一个大型异构图，将原始问题转换为节点分类任务</strong>。我们分别根据调用关系和API使用模式构建“App-API”和“API-API”边。然后将异构图输入 GCN 模型，迭代生成包含拓扑结构和节点特征的节点嵌入。最终，未标记的应用程序根据其最终嵌入进行分类。据我们所知，本文是第一篇探索图神经网络在恶意软件分类领域应用的研究。我们开发了一个名为 GDroid 的原型系统。实验表明，GDroid 可以有效检测 98.99% 的 Android 恶意软件，误报率低于 1%，优于现有方法。它还在恶意软件家族分类任务中实现了近 97% 的平均准确率，超过了基线。此外，我们与奇安信技术研究院合作评估其现实世界影响，GDroid 在现实场景中也保持了令人满意的表现。</p>
<h1 id="简介" tabindex="-1">简介</h1>
<p>Android作为最常用的移动操作系统，一直是黑客的重要攻击目标。最近的一份安全报告显示，平均每天捕获 12,000 个新的移动恶意软件（360，2018）。大量恶意软件的出现给恶意软件缓解带来了巨大的挑战。</p>
<p>先前的研究表明，新恶意应用程序的主要来源是已知的变体（Fan 等人，2018）。为了加速恶意软件分析，研究人员将恶意软件分为不同的家族以协助分析。属于同一家族的恶意应用程序表现出相似的行为，甚至是同一恶意软件的变体。例如，家庭GinMaster默默地将机密信息传输到远程服务器，而DroidKungFu则允许黑客远程控制设备。将未见过的恶意应用程序正确分类到其家族中有助于缓解恶意软件。</p>
<p>本文提出了一种基于图神经网络的 Android 恶意软件检测和家族分类的新方法。具体来说，我们首先将应用程序和 Android API 映射到一个大型异构图中。然后我们分别利用两种关系，（1）应用程序和API之间的调用关系和（2）API使用模式，构建“App-API”和“API-API”边。随后将异构图输入图神经网络模型 GCN（Kipf 和 Welling，2016）中，以生成节点的信息嵌入（即高维数值向量）。最终，未标记的应用程序根据其最终嵌入进行分类。</p>
<p>与我们最相似的现有工作是 HinDroid (Hou et al., 2017)。他们利用异构信息网络 (HIN)（Sun 和 Han，2012）对应用程序、API 及其关系进行建模。他们建模了三种关系：（1）应用程序和 API 之间的调用关系，（2）API 之间的相对位置关系（即 API 是否共存于同一代码块中），以及（3）API 的包和方法名称（即 API 是否具有相同的包或方法名称）。然后，他们通过应用程序上的元路径（Sun 和 Han，2012）计算基于路径的相似性，并通过多内核支持向量机执行分类。从我们的角度来看，包名和方法名都是API的一部分，这样可以简化关系。此外，他们的方法依赖于基于路径的相似性，而最近的研究表明它无法完全挖掘图的潜在结构信息（Shi et al., 2019）。与 HinDroid 相比，我们只建模两种关系，使得异构图更加简单。此外，我们的方法基于图神经网络，它可以利用拓扑结构和节点特征为每个节点生成信息嵌入。</p>
<p>我们开发了一个名为 GDroid 的原型系统，并进行了大量的实验来评估其性能。对于恶意软件检测任务，实验数据集由两部分组成：良性应用程序来自 Google Play Store (GP) (Google, 2017)，恶意应用程序来自 Android Malware Dataset (AMD) (Wei et al., 2017) ）。对于恶意软件家族分类任务，使用三个恶意软件数据集：(1) Android 恶意软件基因组计划 (AMGP)（Zhou 和 Jiang，2012）、(2) Drebin (DB)（Gascon 等人，2014）和 (3) AMD（ Wei et al., 2017）被用来构建一系列具有不同数量家庭的实验数据集。我们将 GDroid 与现有方法在各种指标上进行比较，包括准确率、精确率、召回率、F 测量、假阳性率 (FPR) 和假阴性率 (FNR)1。比较结果证明了 GDroid 对于这两个任务的优越性。</p>
<p>主要贡献可概括如下：<br>
• 我们提出了一种基于 GCN 模型的恶意软件检测和家族分类的新方法。据我们所知，这是第一个探索图神经网络在恶意软件分类领域应用的研究。<br>
• 我们提出了一种基于嵌入的方法来挖掘API 使用模式。它允许我们的模型利用 Android API 之间的相关性。<br>
• 我们开发了一个名为GDroid 的原型系统。实验结果表明，它可以有效检测 98.99% 的恶意软件，且 FPR（&lt;1%）和 FNR 较低。此外，它在恶意软件家族分类任务中实现了近 97% 的平均准确率。比较结果表明，GDroid 在这两个任务上优于现有方法。 GDroid 在现实场景中也保持了令人满意的性能。</p>
<h1 id="相关工作" tabindex="-1">相关工作</h1>
<p>我们的研究基于以下领域的最新进展：恶意软件检测和分类、词嵌入和图神经网络。</p>
<h2 id="2-1-android" tabindex="-1">2.1.基于图的 Android 恶意软件检测</h2>
<p>低级原始特征，例如字节码（Xu 等人，2018；Yuan 等人，2020；Zhang 等人，2019）、操作码（Canfora 等人，2016；Kim 等人，2019；McLaughlin 等人） .，2017；Pektas 和 Acarman，2019）、字符串（Kim 等人，2019；Wang 等人，2018）、权限（Gascon 等人，2014；Kim 等人，2019；Li 等人，2018） ；Vinayakumar 等人，2018；Yerima 和 Sezer，2019）和 API（Allen 等人，2018；Gascon 等人，2014；Jerbi 等人，2020；Nix 和 Zhang，2017；Zhang 等人，2018） ；Zhou 等人，2019）很浅薄。它们很容易受到代码混淆技术的影响。相比之下，人们认识到高级结构化特征具有更好的鲁棒性，因为修改此类特征的成本相对较高。因此，一些研究人员倾向于使用基于图的特征，例如控制流图（CFG）（Narayanan et al., 2016; Xu et al., 2017）、API依赖图（ADG）（Zhang et al., 2014）和函数调用图 (FCG)（Gascon 等人，2013 年；Hassen 和 Chan，2017 年；Narayanan 等人，2016 年）来表征代码块、函数或整个程序。它们是程序内部的（即，可以为每个程序构建它们），因此我们将它们称为“应用程序内”功能。还有“应用程序间”功能，这意味着它们存在于程序之间。 HinDroid（Hou 等人，2017）使用 HIN 对应用程序、相关 API 及其关系进行建模。 HinDroid 的缺点将在第 1 节中讨论。</p>
<h2 id="2-2" tabindex="-1">2.2.恶意软件家族分类</h2>
<p>最近的恶意软件家族分类研究利用了通过动态或静态分析提取的多级特征。动态分析重点关注程序的运行时信息。马丁等人。 (2018) 使用马尔可夫链对运行时应用程序行为进行建模。蔡等人。 (2019) 记录了运行时 API 调用和组件间意图通信。阿尔扎伊拉伊等人。 (2020) 提出了一种深度学习系统，通过状态输入生成来检测恶意 Android 应用程序。理论上，动态分析更加稳健，但代价是消耗更多的资源。然而，由于仿真时间和触发方式的限制，动态分析无法覆盖程序的所有行为。 Android的事件驱动机制也给仿真带来了困难。相比之下，静态分析在大多数情况下可以实现对程序的全面覆盖，而不需要消耗太多的资源。张等人。 (2019) 使用多个原始特征的 n-gram 来对应用程序进行建模。范等人。 (2018) 提出了一种加权安全相关 API 调用图匹配算法来表征应用程序。周等人。 (2017) 试图找到每个恶意软件家族中每个安全相关 API 的最大同构子图，以提取家族特征。加西亚等人。 (2018) 使用敏感 API 和库中的调用来描述应用程序，并基于机器学习算法执行恶意软件检测和家族分类。米尔扎伊等人。 (2019) 提出了一种 Android 恶意软件家族的表征系统，该系统基于从不同家族的聚合调用图中提取的敏感 API 调用集合。</p>
<p>然而，现有的恶意软件家族分类研究仅限于“应用内”功能。 “应用间”信息尚未受到足够的重视。在本文中，我们利用“应用程序间”信息构建一个用于应用程序分类的大型异构图。</p>
<h2 id="2-3-word2vec" tabindex="-1">2.3. Word2vec</h2>
<p>单词嵌入是自然语言处理（NLP）领域的一种无监督学习技术。 Word2Vec（Mikolov 等人，2013a）是一种广泛使用的方法，可以生成上下文感知的词嵌入。如果两个单词具有相似的上下文，则相应的嵌入在嵌入空间中将彼此靠近，反之亦然。例如，“Paris”这个词离“Tokyo”这个词很近，而离“Apple”这个词很远。 Word2Vec 包含两个模型：连续词袋 (CBOW) 和 Skip-gram。 CBOW 模型从周围上下文单词的窗口中预测当前单词，而 Skip-gram 模型使用当前单词来预测周围单词。根据经验，对于不常见的单词，Skip-gram 模型的表现优于 CBOW（Mikolov 等人，2013a）。由于与安全相关的API调用并不频繁，并且不同方法中API调用的次数可能会有很大差异，因此我们选择Skipgram模型来进行API嵌入。</p>
<h2 id="2-4" tabindex="-1">2.4.图神经网络</h2>
<p>图卷积网络（Kipf and Welling，2016）提出的图卷积网络是一种针对图结构数据的半监督分类模型。基本思想是通过在节点之间传播信息来更新节点表示。 GCN表现出很强的表示能力，在各个领域的任务中都表现出色，例如自然语言处理（Gao et al., 2019; Liu et al., 2018; Yao et al., 2018）、推荐系统（Wang et al., 2018）、推荐系统（Wang et al., 2018）等。 ，2019；Wu 等人，2019；Ying 等人，2018）、计算机视觉（Chen 等人，2018；2019）和生物医学（Mao 等人，2019；Zhang 和 Kabuka，2018）。据我们所知，本文是第一篇探索图神经网络在恶意软件分类中应用的研究。</p>
<h1 id="方法论" tabindex="-1">方法论</h1>
<p>图1展示了GDroid的整体工作流程。给定一组应用程序，包括标记的和未标记的，有以下步骤：（1）从应用程序中提取API共现特征。 (2)基于API共现特征进行API嵌入。 (3) 通过嵌入之间的距离度量来挖掘 API 使用模式。 (4) 将应用程序和 API 映射到异构图中。 “App-to-API”边由调用关系建立，“API-to-API”边由 API 使用模式构建。 (5) 将异构图输入 GCN 模型，迭代生成节点嵌入，将相邻信息与节点特征聚合。 (6) 根据最终嵌入对未标记的应用程序进行分类。</p>
<h2 id="3-1" tabindex="-1">3.1.特征提取</h2>
<p>根据经验，程序通过调用系统API来实现其功能，因此Android API的调用与应用程序的行为直接相关。现有研究通常将API视为二元特征（例如，通过检查应用程序是否调用特定API来构造特征向量，而每个API对应一个维度）。然而，这种做法将 API 视为彼此独立，忽略了它们之间潜在的相关性。在这里，我们采取更全面的方法。我们构建了一个异构图来保存应用程序和 API，利用应用程序和 API 之间的调用关系，并利用 API 使用模式来建模 API 之间的相关性。</p>
<p>通过普通的静态分析可以提取调用关系，但API使用模式的获取比较复杂。为此，我们提出了一种基于 API 共现特征的嵌入方法。具体来说，我们将同一方法调用的API视为同现。 API共现特征存在于API序列中，每个内部方法对应一个API序列。图 2 显示了一个示例。它是与检查网络连接相关的内部方法。根据smali代码，调用了三个不同的API，从而构成了该方法的共现特征。</p>
<h2 id="3-2-api" tabindex="-1">3.2. API使用模式挖掘</h2>
<p>为了挖掘 API 使用模式，我们首先根据 API 共现特征执行 API 嵌入，然后根据嵌入之间的距离度量总结具有相似用法的 API。接下来，我们首先介绍原始的 Skip-gram 模型，然后详细介绍我们基于嵌入的方法。</p>
<h3 id="3-2-1-skip-gram" tabindex="-1">3.2.1. Skip-Gram 模型</h3>
<p>Skip-gram 模型（Mikolov 等人，2013b）可以生成上下文感知的词嵌入。它使用在文本上移动的固定大小的滑动窗口来生成训练样本。训练样本存在于 (x, y) 对中，其中 x 是输入，y 是标签。该模型使用在文本上移动的滑动窗口来生成训练数据。图 3 说明了这个过程。位于中间的单词被视为输入，其他单词被视为目标。结果，生成了四个训练样本：(sat,the)、(sat,cat)、(sat,on)和(sat,a)。训练目标是调整词嵌入，以便它们可以用来预测周围的词。形式上，给定一个单词序列 w1, w2, w3, ... 。 。 , wT ，模型最大化平均对数概率为</p>
</main>
<script>window.location.hash&&document.getElementById(window.location.hash.slice(1)).classList.add("referred"),window.addEventListener("hashchange",(e=>{const t=e.oldURL.split("#");t[1]&&document.getElementById(t[1]).classList.remove("referred");const n=e.newURL.split("#");n[1]&&document.getElementById(n[1]).classList.add("referred")}),!1);const url_parts=window.location.href.split("#"),url=url_parts[0],referrence=url_parts[1];document.querySelectorAll(".cm-s-obsidian > *[id]").forEach((function(e){e.ondblclick=function(e){const t=url+"#"+e.target.id;navigator.clipboard.writeText(t)}}))</script>
<script src="https://fastly.jsdelivr.net/npm/luxon@3.2.1/build/global/luxon.min.js"></script>
<script defer="defer">TIMESTAMP_FORMAT="MMM dd, yyyy h:mm a",document.querySelectorAll(".human-date").forEach((function(e){date=e.getAttribute("data-date")||e.innerText,parsed_date=luxon.DateTime.fromISO(date),null!=parsed_date.invalid&&(parsed_date=luxon.DateTime.fromSQL(date)),null!=parsed_date.invalid&&(parsed_date=luxon.DateTime.fromHTML(date)),e.innerHTML=parsed_date.toFormat(TIMESTAMP_FORMAT)}))</script>
<script>lucide.createIcons({attrs:{class:["svg-icon"]}})</script>
</body>
</html>
