<!doctype html>
<html lang="en">
<head>
<title>202402.通过提取 API 语义来实现的一个新颖的安卓恶意软件检测方法。AnovelAndroid malware detection method with API semantics extraction</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<script async type="module">import mermaid from"https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs"</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-sv0slik/5O0JIPdLBCR2A3XDg/1U3WuDEheZfI/DI5n8Yqc3h5kjrnr46FGBNiUAJF7rE4LHKwQ/SoSLRKAxEA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script async src="https://cdn.jsdelivr.net/npm/lucide@0.115.0/dist/umd/lucide.min.js"></script>
<script>window.addEventListener("load",(()=>{document.querySelectorAll(".callout").forEach((e=>{const t=getComputedStyle(e).getPropertyValue("--callout-icon"),l=t&&t.trim().replace(/^lucide-/,"");if(l){const t=e.querySelector(".callout-title");if(t){const e=document.createElement("div"),c=document.createElement("i");e.appendChild(c),c.setAttribute("icon-name",l),e.setAttribute("class","callout-icon"),t.insertBefore(e,t.firstChild)}}})),lucide.createIcons(),Array.from(document.querySelectorAll(".callout.is-collapsible")).forEach((e=>{e.querySelector(".callout-title").addEventListener("click",(t=>{e.classList.contains("is-collapsed")?e.classList.remove("is-collapsed"):e.classList.add("is-collapsed")}))}))}))</script>
<script async src="https://fastly.jsdelivr.net/npm/force-graph@1.43.0/dist/force-graph.min.js"></script>
<script async src="https://fastly.jsdelivr.net/npm/@alpinejs/persist@3.11.1/dist/cdn.min.js"></script>
<script src="https://fastly.jsdelivr.net/npm/alpinejs@3.11.1/dist/cdn.min.js" async></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-okaidia.min.css" integrity="sha512-mIs9kKbaw6JZFfSuo+MovjU+Ntggfoj8RwAmJbVXQ5mkAX5LlgETQEweFPI18humSPHymTb5iikEOKWF7I8ncQ==" crossorigin="anonymous" referrerpolicy="no-referrer" async>
<script src="https://fastly.jsdelivr.net/npm/whatwg-fetch@3.6.2/dist/fetch.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer" async></script>
<link href="/styles/digital-garden-base.css" rel="stylesheet">
<link href="/styles/obsidian-base.css" rel="stylesheet">
<link href="/styles/_theme.d92311c2.css" rel="stylesheet">
<link href="/styles/custom-style.css" rel="stylesheet">
<link rel="icon" href="/favicon.ico" sizes="any">
<link rel="icon" href="/favicon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="manifest" href="/manifest.webmanifest">
<style></style>
</head>
<body class="theme-dark markdown-preview-view markdown-rendered markdown-preview-section">
<nav class="navbar">
<div class="navbar-inner">
<a href="/" style="text-decoration:none">
<h1 style="margin:15px!important">Digital Garden</h1>
</a>
</div>
</nav>
<main class="content cm-s-obsidian">
<header>
<div class="header-meta">
</div>
</header>
<p><img src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/202402.%E9%80%9A%E8%BF%87%E6%8F%90%E5%8F%96%20API%20%E8%AF%AD%E4%B9%89%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E6%96%B0%E9%A2%96%E7%9A%84%E5%AE%89%E5%8D%93%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95_image.png" alt="202402.通过提取 API 语义来实现的一个新颖的安卓恶意软件检测方法_image.png"></p>
<p>[[A novel Android malware detection method with API semantics extraction_2024_Yang et al.pdf]]</p>
<p>AnovelAndroid malware detection method with API semantics extraction<br>
一个新颖的安卓恶意软件检测方法，通过提取 API 语义来实现。</p>
<p>关键词：进化恶意软件检测、模型老化、API语义、函数调用图、机器学习。</p>
<h1 id="摘要" tabindex="-1">摘要</h1>
<p>由于Android框架和恶意软件的持续进化，使用过时应用程序训练的传统恶意软件检测方法在有效识别复杂的进化恶意软件方面已不足够。为了解决这个问题，本文提出了一种新颖的安卓恶意软件检测方法，名为API语义提取的安卓恶意软件检测方法（AMDASE），它可以有效识别进化的恶意软件实例。首先，<strong>AMDASE</strong> 执行<strong>API聚类</strong>以获取代表API功能的聚类中心，然后在恶意软件检测之前设计API句子来<strong>总结API特征</strong>，并使用<strong>自然语言处理（NLP）工具</strong>获取API句子的嵌入，用于聚类。借助API句子，可以有效地提取包含在诸如方法名称这样的特征中的API语义，这些特征准确地代表了其预期功能，这也使得聚类结果更加准确。其次，AMDASE 从每个应用中提取<strong>调用图</strong>，并通过移除与未知功能对应的节点来优化调用图，同时确保保留它们的前驱节点和后继节点之间的连通性。优化后的调用图可以提取更健壮的API上下文信息，准确地代表每个应用的行为。第三，为了保持对Android恶意软件进化的抵抗力，AMDASE 从优化的调用图中提取函数调用对，并将函数调用对中的API抽象为API聚类中获得的聚类中心。最后，使用一键映射生成特征向量，并使用机器学习分类器进行恶意软件检测。我们在一个包含42,154个良性和42,450个恶意应用的数据集上评估AMDASE，这些应用是在七年的时间里开发的。实验结果表明，AMDASE 的性能大大超过了现有的最先进方法，并且具有显著较慢的老化速度。</p>
<h1 id="1" tabindex="-1">1. 引言</h1>
<p>Android平台的广泛普及推动了Android恶意软件的快速扩张。尽管机器学习技术在恶意软件检测方面取得了优异的成果（Qiu等，2020年），但恶意软件的持续进化仍然对检测系统构成了巨大挑战（Jordaney等，2017年）。使用过时应用程序训练的分类器难以有效检测出一段时间后出现的新应用，导致检测性能随时间持续下降，这也被称为模型老化。模型老化是由概念漂移引起的，与计算机视觉或自然语言处理（NLP）不同，恶意软件检测的问题域频繁变化，导致新出现的恶意软件与旧恶意软件之间的特征分布存在差异。恶意软件开发者常通过改变实现方式来逃避检测系统，以保持恶意行为（张等，2020年）。具体来说，进化的恶意软件拥有大量未出现在训练集中的API。目前，大多数恶意软件检测方法都基于API调用信息。基于API频率信息的检测方法（杨等，2014年；Arp等，2014年；冯等，2020年）显示出高误报率，并容易受到恶意攻击。依赖API上下文信息的检测方法（吴等，2019年；艾伦等，2018年）在识别应用程序表现出的恶意行为方面提高了准确性。然而，由于缺乏适当的方法处理调用图中大量未知功能节点，这种方法在有效提取API上下文信息方面面临挑战。此外，这些现有的检测方法未能考虑API的频繁变化，因此在有效识别进化的恶意软件方面面临挑战。API聚类将具有相似功能的API分组到同一类别中。在恶意软件检测过程中，可以用API聚类中心替换特征向量中的API，以增强分类器识别训练阶段未遇到的API的能力。这种方法有可能减缓分类器性能随时间衰减的速度（张等，2020年）。然而，现有的API聚类方法从包名、参数和返回值等特征中提取API语义，而忽略了方法名和权限等关键特征。通过API聚类提升分类器性能的限度可以归因于API语义提取的不足。Mariconti等（2016年）提出了MAMADROID，其中他们采用了一种聚类技术，根据包名对API进行分组。MAMADROID通过将新引入的API抽象为包，显示出对现有包中API的弹性。然而，需要注意的是，同一包中的API不一定表现出相似的功能。此外，MAMADROID无法从新包中捕获任何API信息。Pendlebury等（2019年）发现，在消除时间偏差的实验设置下，MAMADROID的F1-测量值在仅三个月后从90%以上下降到58%。为了解决现有恶意软件检测方法中的上述缺陷，我们提出了一种新颖的Android恶意软件检测方法，即API语义提取的Android恶意软件检测方法（AMDASE），该方法可以有效检测进化的恶意软件。首先，我们进行API聚类，以获得代表API功能的聚类中心。我们设计API句子来总结API特征，并使用NLP工具获取API句子的嵌入，用于聚类。其次，我们从每个应用中提取调用图，并通过移除未知功能节点的同时保留其前驱节点和后继节点之间的连接来优化调用图。第三，我们从优化的调用图中提取函数调用对，并将调用对中的API抽象为API聚类部分获得的聚类中心。最后，使用一键编码生成特征向量，并使用机器学习分类器进行恶意软件检测。我们在一个包含42,154个良性应用和42,450个恶意应用的数据集上评估AMDASE的检测性能，这些应用是在七年的时间里开发的。AMDASE在2012年到2013年的数据上训练，当检测2014年到2018年的样本时，平均F1-测量值达到82.6%。平均F1-测量值比最先进的恶意软件检测方法MAMADROID高出22%。我们的实验结果表明，AMDASE的性能大大超过了现有的检测方法，并且老化速度明显较慢。本文主要做出三个贡献：首先，我们提出了一种基于语义距离的API聚类方法。我们设计API句子来总结API的特征。API句子不仅包含重要的特征，如概述API功能的方法名，还将具有不一致特征数量的API统一映射到固定大小的特征向量中。借助API句子，可以有效地提取API的语义，这使得API聚类结果更加准确。其次，我们引入了一种调用图优化方法。这种方法在保持其前驱节点和后继节点之间的连接的同时，移除了所有未知节点。如果调用图中任意两个API节点（例如，APIx和APIy）之间存在由所有未知功能节点组成的路径，则在优化的调用图中，APIx直接调用APIy。调用图优化使得提取的API上下文信息能更精确地反映应用的行为模式。最后，我们介绍了AMDASE，这是一种新颖的Android恶意软件检测方法，可以有效识别进化的恶意软件，无需任何类型的重新训练。通过将API抽象为聚类中心，AMDASE对Android框架和恶意软件中的API变化具有弹性。</p>
<h1 id="2" tabindex="-1">2. 相关工作</h1>
<p>机器学习在Android恶意软件检测方面取得了显著进展（Wu等，2023年；Bhat等，2023年；Tarwireyi等，2023年；Yang等，2015年；Zhang等，2014年；Yang等，2014年；Karbab等，2018年；Chen等，2018年；Feng等，2020年；Wang等，2019年，2018年；Liu等，2019年；Lu等，2021b年）。然而，模型老化的问题始终是一个重大挑战。Pendlebury等（2019年）和Jordaney等（2017年）详细说明了概念漂移在Android恶意软件检测中的普遍性。研究人员提出了许多解决方案来应对这一问题，主要可以分为四类：重新训练、应用关系图、异常样本识别和API聚类。</p>
<h2 id="2-1" tabindex="-1">2.1. 基于重新训练的恶意软件检测</h2>
<p>“重新训练”一词涉及到利用概念漂移样本及其相应标签重新训练分类器的过程。根据标签的不同来源，重新训练的过程可以分为两种类型：真实标签重新训练和伪标签重新训练。真实标签来自恶意软件专家的手动标注。而“伪标签”指的是由恶意软件分类器生成的推断类标签，通常以其预测的高置信度为特征。Grosse等（2017年）提出了一种自适应且可扩展的Android恶意软件检测方法DroidOL。DroidOL系统利用调用图提取应用的敏感行为特征，并在检测过程中利用误分类样本及其相应的真实标签更新分类器。因此，DroidOL能够适应Android应用的进展。Xu等（2019年）提出了一种基于在线学习的恶意软件检测方法DroidEvolver。DroidEvolver认为，用不同优化器训练的分类器具有不同的老化速度，因此在训练阶段构建了一个由五个线性在线学习算法组成的模型池。在检测阶段，使用其他未老化模型的预测结果更新老化模型。基于重新训练的检测方法通常有以下缺陷：重新训练真实标签需要大量高质量的概念漂移样本，这在有限的时间内难以完成。此外，重新训练真实标签还需要大量人力资源进行概念漂移样本的手动标注。伪标签重新训练免除了人力资源手动标注样本的需要，但伴随着两个固有的限制。首先，一旦预测标签错误，将导致分类器性能急剧下降。另一个缺点是，恶意攻击者可以设计特定样本来利用伪标签重新训练的机制。</p>
<h2 id="2-2" tabindex="-1">2.2. 基于应用关系图的恶意软件检测</h2>
<p>应用关系图指的是构建一个以每个应用为主节点的实体关系图，以反映不同应用之间的相似性。Android生态系统经历的是逐渐的进化过程，而不是突变，导致进化的恶意软件保留了与其祖先相似的显著特征。一旦概念漂移应用被误分类，分类器可能会使用该应用与其祖先节点在应用关系图中的相似性，将其拉回到决策边界。Gu和Li（2021年）提出了一种缓解Android恶意软件检测中模型老化的方法。它构建了一个应用关系图来反映应用之间的进化关系，这个图辅助分类器进行恶意软件检测。Hei等（2021年）提出了一种基于异构图注意网络的Android恶意软件检测方法。在训练阶段，构建了一个应用关系图来模拟应用之间的相似性。然后，使用图神经网络学习应用之间的相似性并生成用于恶意软件检测的特征向量。在检测阶段，设计了一种增量聚合方法MsGAT++，使得无需更新整个应用关系图即可快速生成特征向量。基于应用关系图的检测方法通常有以下缺陷：首先，代码重用是软件开发的重要部分，因为它允许开发者将现有代码用于各种目的。然而，值得注意的是，代码重用的做法不仅限于良性应用，恶意行为者也可能在恶意软件开发中使用来自良性应用的重用代码。这给利用应用之间的相似性的恶意软件检测方法带来了严重困难。同时，应用之间的相似性并不反映它们的行为，这对基于应用关系图的检测方法学习恶意软件与良性应用之间行为特征的差异构成了挑战。</p>
<h2 id="2-3" tabindex="-1">2.3. 基于异常样本识别的恶意软件检测</h2>
<p>异常样本识别是在检测过程中过滤出概念漂移样本。恶意软件分类器对这些样本的决策通常信心较低，因此需要恶意软件专家的参与，以评估并做出明智的判断。Yuan等（2022年）提出了一种使用双头神经网络进行概念漂移样本识别的方法。这个神经网络有两个平行的输出层，分别输出应用的预测结果。通过这两个输出层之间的差异来识别概念漂移样本。Karbab和Debbabi（2021年）提出了一种自适应的Android恶意软件检测方法。分类器在对概念漂移样本做出决策时通常信心较低，因此在恶意软件检测过程中会过滤掉低信心样本。异常样本识别可以大大提高检测方法的有效性，但它仅限于识别概念漂移样本，而不是进化恶意软件检测。</p>
<h2 id="2-4-api" tabindex="-1">2.4. 基于API聚类的恶意软件检测</h2>
<p>API聚类将具有相似功能的API分组到同一类别中。在恶意软件检测过程中，用API聚类中心替换特征向量中的API，增强了检测方法对API频繁变化的抵抗力。MAMADROID（Mariconti等，2016年）通过包名对API进行聚类。通过将API调用抽象为包，MAMADROID对新引入的API显示出弹性，这些API出现在现有包中。然而，同一包中的API不一定执行相似的功能（Zhang等，2020年）。此外，MAMADROID无法从新包中捕获任何API信息。Zhang等（2020年）提出了APIGRAPH，这是对现有Android恶意软件分类器的一种增强，通过API聚类实现。首先，APIGRAPH从Android官方文档中提取信息以构建实体关系图。然后，使用TransE（Van der Maaten和Hinton，2008年）算法生成实体和关系的嵌入向量。最后，使用k-Means（Syakur等，2018年）算法进行API聚类。作者认为，具有相似参数、相似权限、相似包和相似返回值的API必定具有相似的功能。然而，在API语义提取过程中，包含大量语义信息的API方法名被忽略了。Lei等（2019年）引入了一种使用API标记的API聚类方法。最初，它将调用图中的每个API分割为标记，包括其家族、包名、类名、方法名、返回值和参数。然后，使用doc2vec（Lau和Baldwin，2016年）对每个API进行编码并生成嵌入。最后，使用k-Means算法完成聚类。这种API聚类方法在API语义提取过程中使用了方法名，但忽略了权限和异常等关键特征。权限在Android系统中极为重要（Au等，2012年）。同时，这种方法从训练集而不是API文档中收集API，这使得该方法无法识别测试集中出现的新API。Xu等（2020年）提出了一种使用调用图中API上下文信息的API聚类方法。这种方法认为，展示出相似的调用者和被调用者模式的API很可能具有类似的功能。因此，设计了一个双层神经网络来捕捉API调用及其上下文信息之间的潜在关系。神经网络中的隐藏层用作反映API语义的嵌入，用于聚类。然而，这种方法使用训练数据和测试数据一起训练神经网络，这是一种严重的数据窥探（Quiring等，2022年）行为。在实际场景中，这种方法无法识别测试集中出现的新API。与其他方法相比，API聚类是解决进化恶意软件检测问题最直接和有效的解决方案。然而，现有的聚类方法在API语义提取过程中忽略了方法名和权限等关键特征，导致聚类结果对分类器性能的提升有限。</p>
<h1 id="3-amdase" tabindex="-1">3. AMDASE概述</h1>
<p>AMDASE是一种使用API上下文信息的静态恶意软件检测方法。该系统展示了强大的检测进化恶意软件的能力。图1展示了AMDASE的框架。它由两部分组成：基于语义距离的API聚类和Android恶意软件检测。基于语义距离的API聚类生成代表每个API功能的API聚类中心，在Android恶意软件检测之前完成。基于语义距离的API聚类有四个步骤。首先，从Android官方文档中提取每个API的特征（图1中的步骤a），包括异常、权限、参数、返回值等。其次，根据规定的规则生成API句子（图1中的步骤b）。第三，使用Bert（Jacob等，2019年），一个成熟的NLP模型，对API句子进行编码，获取每个API的嵌入（图1中的步骤c）。最后，我们使用k-Means算法生成代表API功能的聚类中心（图1中的步骤d），并将具有相似语义的API分组在一起。</p>
<p>Android恶意软件检测过程包括五个步骤。首先，使用FlowDroid（Arzt等，2014年），一个静态分析工具，从每个应用中提取函数调用图（图1中的步骤1）。此外，通过消除代表未知功能的节点，同时确保其前驱节点和后继节点之间的连接被保持，优化调用图（图1中的步骤2）。进一步，从调用图中提取函数调用对（图1中的步骤3）。在第四步，最初将函数调用对抽象为API聚类对。接下来，我们继续将剩余方法抽象为其相应的包。最后，使用一键编码生成每个应用的特征向量（图1中的步骤4）。在最后一步，将特征向量输入机器学习分类器，以预测应用是恶意的还是良性的（图1中的步骤5）。</p>
<h1 id="4-api" tabindex="-1">4. 基于语义距离的API聚类</h1>
<p>基于语义距离的API聚类包括四个部分：API特征提取、API句子生成、API句子编码和聚类中心生成。</p>
<h2 id="4-1-api" tabindex="-1">4.1. API特征提取</h2>
<p>特征提取是从Android官方文档中提取每个API的特征（Api文档，2023年）。我们研究中使用的特征包括七个不同的类别：包名、类名、方法名、参数、权限、异常和返回值。APIGRAPH的作者提供了收集的Android官方文档和API特征提取的源代码（Apigraph，2023年）。通过复制源代码，我们能够获得所有API及其相应的特征。现有的API聚类方法在API语义提取时忽略了方法名，然而，API的方法名包含大量信息并勾画出API的功能。通过使用NLP模型，可以有效地提取API方法名中嵌入的语义信息，从而提供其预期功能的近似表示。例如，具有方法名如‘getDeviceId’或‘setWifiEnabled’的API。它们的方法名使我们能够轻松理解它们的功能。表1显示了名为Android.telephony.TelephonyManager.getDeviceId的API的特征提取结果。注意，为了减少一些广泛使用的特征值对API语义提取的影响，我们忽略了如int、boolean、String和float等特征值。表1中显示的API以int为参数并返回String。在特征提取过程中忽略了这两个特征值。除了APIGRAPH中现有的特征提取方法外，我们通过利用它们的驼峰命名（除了第一个词，其余词的首字母都是大写，如‘setWifiEnabled’和‘sendTextMessage’）将方法名和类名分开为单词来修改API特征。表1中显示的API的方法名为‘getDeviceID’，可以分为三个单词：’get’、‘Device’和‘ID’，用‘$’分隔。注意，类名和方法名中的一些词都是大写的，如‘SQL’、‘URL’和表1中的‘ID’，这些词是缩写，需要额外处理。</p>
<h2 id="4-2-api" tabindex="-1">4.2. API句子生成</h2>
<p>在特征提取完成后，我们将API转换为能够反映其语义信息的嵌入向量。这部分面临的问题是相同特征的值数量不一致。例如，某些API的方法名可以分解为五个词，而有些API只能分解为三个词。一些API需要调用权限，而其他的则不需要。因此，需要设计一种嵌入方法，该方法不仅能表示API的语义信息，还能将所有具有可变数量特征值的API统一映射为固定大小的特征向量，这些向量最终用于后续聚类中的距离计算。</p>
<p>为解决这个问题，我们首先将每个API及其特征转换为一个句子，称为API句子。根据特征值的数量，API句子的生成分为通用部分和唯一部分。通用部分指的是所有API都具有且仅有一个值的三个共同特征：方法名、类名和包名。通用部分句子生成规则如下：<br>
方法 𝑀𝑒𝑡ℎ𝑜𝑑 来自类 𝐶𝑙𝑎𝑠𝑠 来自包 𝑃𝑎𝑐𝑘</p>
<p>唯一部分包含四种类型的特征：权限、异常、参数和返回值。对于这些唯一特征，每个API都有不同数量的特征值。<strong>表2</strong>列出了唯一部分句子生成的规则。<strong>算法1</strong>展示了API句子生成的伪代码。输入是APIx的七种类型的特征，输出是APIx的API句子𝑆。第1至3行生成API句子中通用特征的对应部分；第4至7行调用<strong>算法2</strong>来生成API句子中唯一特征的对应部分；第8行将𝑆中所有大写字母替换为小写字母；第7行将𝑆中的每个'$'、''和'.'替换为空格。</p>
<p><strong>算法2</strong>展示了API句子生成中唯一特征处理的伪代码。<strong>算法2</strong>由<strong>算法1</strong>的第4至7行调用。输入是唯一特征的特征值列表𝐹𝑒𝑎𝑡𝑢𝑟𝑒𝑠和相应的API句子生成规则𝑅0和𝑅1。输出是对应于唯一特征的API句子部分𝑆𝑃𝑎𝑟𝑡。<strong>算法2</strong>考虑了特征值数量为0或至少为1的两种情况。</p>
<p>将<strong>表1</strong>中显示的API及其特征输入<strong>算法1</strong>后，我们可以得到以下API句子：&quot;method get device id from class telephony manager from package Android telephony use permission read phone state throw none exception use none parameter return none&quot;。</p>
</main>
<script>window.location.hash&&document.getElementById(window.location.hash.slice(1)).classList.add("referred"),window.addEventListener("hashchange",(e=>{const t=e.oldURL.split("#");t[1]&&document.getElementById(t[1]).classList.remove("referred");const n=e.newURL.split("#");n[1]&&document.getElementById(n[1]).classList.add("referred")}),!1);const url_parts=window.location.href.split("#"),url=url_parts[0],referrence=url_parts[1];document.querySelectorAll(".cm-s-obsidian > *[id]").forEach((function(e){e.ondblclick=function(e){const t=url+"#"+e.target.id;navigator.clipboard.writeText(t)}}))</script>
<script src="https://fastly.jsdelivr.net/npm/luxon@3.2.1/build/global/luxon.min.js"></script>
<script defer="defer">TIMESTAMP_FORMAT="MMM dd, yyyy h:mm a",document.querySelectorAll(".human-date").forEach((function(e){date=e.getAttribute("data-date")||e.innerText,parsed_date=luxon.DateTime.fromISO(date),null!=parsed_date.invalid&&(parsed_date=luxon.DateTime.fromSQL(date)),null!=parsed_date.invalid&&(parsed_date=luxon.DateTime.fromHTML(date)),e.innerHTML=parsed_date.toFormat(TIMESTAMP_FORMAT)}))</script>
<script>lucide.createIcons({attrs:{class:["svg-icon"]}})</script>
</body>
</html>
