<!doctype html>
<html lang="zh-CN">
<head>
<title>7-Apache Hive SQL DQL、参数配置与函数</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<script async type="module">import mermaid from"https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs"</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-sv0slik/5O0JIPdLBCR2A3XDg/1U3WuDEheZfI/DI5n8Yqc3h5kjrnr46FGBNiUAJF7rE4LHKwQ/SoSLRKAxEA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script async src="https://cdn.jsdelivr.net/npm/lucide@0.115.0/dist/umd/lucide.min.js"></script>
<script>window.addEventListener("load",(()=>{document.querySelectorAll(".callout").forEach((e=>{const t=getComputedStyle(e).getPropertyValue("--callout-icon"),l=t&&t.trim().replace(/^lucide-/,"");if(l){const t=e.querySelector(".callout-title");if(t){const e=document.createElement("div"),c=document.createElement("i");e.appendChild(c),c.setAttribute("icon-name",l),e.setAttribute("class","callout-icon"),t.insertBefore(e,t.firstChild)}}})),lucide.createIcons(),Array.from(document.querySelectorAll(".callout.is-collapsible")).forEach((e=>{e.querySelector(".callout-title").addEventListener("click",(t=>{e.classList.contains("is-collapsed")?e.classList.remove("is-collapsed"):e.classList.add("is-collapsed")}))}))}))</script>
<script async src="https://fastly.jsdelivr.net/npm/force-graph@1.43.0/dist/force-graph.min.js"></script>
<script async src="https://fastly.jsdelivr.net/npm/@alpinejs/persist@3.11.1/dist/cdn.min.js"></script>
<script src="https://fastly.jsdelivr.net/npm/alpinejs@3.11.1/dist/cdn.min.js" async></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-okaidia.min.css" integrity="sha512-mIs9kKbaw6JZFfSuo+MovjU+Ntggfoj8RwAmJbVXQ5mkAX5LlgETQEweFPI18humSPHymTb5iikEOKWF7I8ncQ==" crossorigin="anonymous" referrerpolicy="no-referrer" async>
<script src="https://fastly.jsdelivr.net/npm/whatwg-fetch@3.6.2/dist/fetch.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer" async></script>
<link href="/styles/digital-garden-base.css" rel="stylesheet">
<link href="/styles/obsidian-base.css" rel="stylesheet">
<link href="/styles/_theme.74516f71.css" rel="stylesheet">
<link href="/styles/custom-style.css" rel="stylesheet">
<link rel="icon" href="/favicon.ico" sizes="any">
<link rel="icon" href="/favicon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="manifest" href="/manifest.webmanifest">
<style></style>
<style></style>
</head>
<body class="theme-light markdown-preview-view markdown-rendered markdown-preview-section css-settings-manager mod-windows is-frameless is-maximized is-hidden-frameless is-focused obsidian-app theme-light show-inline-title show-ribbon show-view-header css-settings-manager theme-default line-style-solid folder-default blockquote-normal callout-normal checkbox-default tag-default link-default heading-default responsive-tile-height oz-show-all-num">
<nav class="navbar">
<div class="navbar-inner">
<a href="/" style="text-decoration:none">
<h1 style="margin:15px!important">czc&#39;s digital garden</h1>
</a>
</div>
<div class="search-button align-icon" onclick="toggleSearch()">
<span class="search-icon">
<i icon-name="search"></i>
</span>
<span class="search-text">
<span>Search</span>
<span style="font-size:.6rem;padding:2px 2px 0 6px;text-align:center;transform:translateY(4px)" class="search-keys">
CTRL + K
</span>
</span>
</div>
</nav>
<div class="search-container" id="globalsearch" onclick="toggleSearch()">
<div class="search-box">
<input type="search" id="term" placeholder="Start typing...">
<div id="search-results"></div>
<footer class="search-box-footer">
<div class="navigation-hint">
<span>Enter to select</span>
</div>
<div class="navigation-hint align-icon">
<i icon-name="arrow-up" aria-hidden="true"></i>
<i icon-name="arrow-down" aria-hidden="true"></i>
<span>to navigate</span>
</div>
<div class="navigation-hint">
<span>ESC to close</span>
</div>
</footer>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js"></script>
<script>document.addEventListener("DOMContentLoaded",init,!1),document.addEventListener("DOMContentLoaded",setCorrectShortcut,!1),window.toggleSearch=function(){document.getElementById("globalsearch").classList.contains("active")?document.getElementById("globalsearch").classList.remove("active"):(document.getElementById("globalsearch").classList.add("active"),document.getElementById("term").focus())},window.toggleTagSearch=function(e){console.log(e.textContent);const t=e.textContent;t&&(window.document.getElementById("term").value=t.trim(),window.toggleSearch(),window.search())};const loadingSvg='\n    <svg width="100" height="100" viewBox="0 0 45 45" xmlns="http://www.w3.org/2000/svg" stroke="#fff">\n      <g fill="none" fill-rule="evenodd" transform="translate(1 1)" stroke-width="2">\n          <circle cx="22" cy="22" r="6" stroke-opacity="0">\n              <animate attributeName="r"\n                   begin="1.5s" dur="3s"\n                   values="6;22"\n                   calcMode="linear"\n                   repeatCount="indefinite" />\n              <animate attributeName="stroke-opacity"\n                   begin="1.5s" dur="3s"\n                   values="1;0" calcMode="linear"\n                   repeatCount="indefinite" />\n              <animate attributeName="stroke-width"\n                   begin="1.5s" dur="3s"\n                   values="2;0" calcMode="linear"\n                   repeatCount="indefinite" />\n          </circle>\n          <circle cx="22" cy="22" r="6" stroke-opacity="0">\n              <animate attributeName="r"\n                   begin="3s" dur="3s"\n                   values="6;22"\n                   calcMode="linear"\n                   repeatCount="indefinite" />\n              <animate attributeName="stroke-opacity"\n                   begin="3s" dur="3s"\n                   values="1;0" calcMode="linear"\n                   repeatCount="indefinite" />\n              <animate attributeName="stroke-width"\n                   begin="3s" dur="3s"\n                   values="2;0" calcMode="linear"\n                   repeatCount="indefinite" />\n          </circle>\n          <circle cx="22" cy="22" r="8">\n              <animate attributeName="r"\n                   begin="0s" dur="1.5s"\n                   values="6;1;2;3;4;5;6"\n                   calcMode="linear"\n                   repeatCount="indefinite" />\n          </circle>\n      </g>\n  </svg>';function debounce(e,t,n){var a;return function(){var r=this,i=arguments,c=n&&!a;clearTimeout(a),a=setTimeout((function(){a=null,n||e.apply(r,i)}),t),c&&e.apply(r,i)}}function setCorrectShortcut(){navigator.platform.toUpperCase().indexOf("MAC")>=0&&document.querySelectorAll(".search-keys").forEach((e=>e.innerHTML="⌘ + K"))}function createIndex(e){const t=e=>e.toLowerCase().split(/([^a-z]|[^\x00-\x7F])/),n=new FlexSearch.Document({cache:!0,charset:"latin:extra",optimize:!0,index:[{field:"content",tokenize:"reverse",encode:t},{field:"title",tokenize:"forward",encode:t},{field:"tags",tokenize:"forward",encode:t}]});return e.forEach(((e,t)=>{n.add({id:t,title:e.title,content:e.content,tags:e.tags})})),n}async function init(){let e=!0;if(localStorage.getItem("searchIndex")){let{date:t,docs:n}=JSON.parse(localStorage.getItem("searchIndex"));if("2025-06-12T11:25:24.315Z"===t){e=!1;let t=createIndex(n);window.docs=n,window.index=t}}if(e){let e=await(await fetch("/searchIndex.json?v=2025-06-12T11:25:24.315Z")).json(),t=createIndex(e);localStorage.setItem("searchIndex",JSON.stringify({date:"2025-06-12T11:25:24.315Z",docs:e})),window.docs=e,window.index=t}document.addEventListener("keydown",(e=>{if((e.ctrlKey||e.metaKey)&&"k"===e.key&&(e.preventDefault(),toggleSearch()),"Escape"===e.key&&document.getElementById("globalsearch").classList.remove("active"),document.getElementById("globalsearch").classList.contains("active")){if("ArrowDown"===e.key){e.preventDefault();let t=document.querySelector(".searchresult.active");t?(t.classList.remove("active"),t.nextElementSibling?t.nextElementSibling.classList.add("active"):document.querySelector(".searchresult").classList.add("active")):document.querySelector(".searchresult").classList.add("active");let n=document.querySelector(".searchresult.active");n&&n.scrollIntoView({behavior:"smooth",block:"nearest",inline:"start"})}if("ArrowUp"===e.key){e.preventDefault();let t=document.querySelector(".searchresult.active");t?(t.classList.remove("active"),t.previousElementSibling?t.previousElementSibling.classList.add("active"):document.querySelectorAll(".searchresult").forEach((e=>{e.nextElementSibling||e.classList.add("active")}))):document.querySelectorAll(".searchresult").forEach((e=>{e.nextElementSibling&&e.classList.add("active")}));let n=document.querySelector(".searchresult.active");n&&n.scrollIntoView({behavior:"smooth",block:"nearest",inline:"start"})}if("Enter"===e.key){e.preventDefault();let t=document.querySelector(".searchresult.active");t&&(window.location.href=t.querySelector("a").href)}}}));const t=debounce(search,200,!1);field=document.querySelector("#term"),field.addEventListener("keydown",(e=>{"ArrowDown"!==e.key&&"ArrowUp"!==e.key&&t()})),resultsDiv=document.querySelector("#search-results");const n=new URL(location.href).searchParams;n.get("q")&&(field.setAttribute("value",n.get("q")),toggleSearch(),search())}async function search(){let e=field.value.trim();if(!e)return;if(e==lastSearch)return;console.log(`search for ${e}`),window.lastSearch=e,resultsDiv.innerHTML=loadingSvg;let t=offlineSearch(e),n="";if(!t.length){let t=document.createElement("p");return t.innerText=`No results for "${e}"`,resultsDiv.innerHTML="",void resultsDiv.appendChild(t)}n+='<div style="max-width:100%;">',t.forEach((e=>{e.tags&&e.tags.length>0?n+=`<div class="searchresult">\n                    <a class="search-link" href="${e.url}">${e.title}</a>\n                    <div onclick="window.location='${e.url}'">\n                        <div class="header-meta">\n                            <div class="header-tags">\n                                ${e.tags.map((e=>'<a class="tag" href="JavaScript:Void(0);">#'+e+"</a>")).join("")}\n                            </div>\n                        </div>\n                        ${e.content}\n                    </div>\n                </div>`:n+=`<div class="searchresult">\n                    <a class="search-link" href="${e.url}">${e.title}</a>\n                    <div onclick="window.location='${e.url}'">\n                        ${e.content}\n                    </div>\n                </div>`})),n+="</div>",resultsDiv.innerHTML=n}function truncate(e,t){return(e=e.replaceAll(/<[^>]*>/g,"")).length<t?e:e.substring(0,t-3)+"..."}function offlineSearch(e){let t=window.docs,n="#"===e[0]&&e.length>1?index.search(e.substring(1),[{field:"tags"}]):index.search(e,[{field:"title",limit:5},{field:"content",weight:10}]);const a=e=>{const t=n.filter((t=>t.field===e));return 0===t.length?[]:[...t[0].result]};return[...new Set([...a("title"),...a("content"),...a("tags")])].map((e=>{let n=t[e];return n.content=truncate(n.content,400),n.tags=n.tags.filter((e=>"gardenEntry"!=e&&"note"!=e)),n}))}window.lastSearch=""</script>
<main class="content cm-s-obsidian">
<header>
<h1 data-note-icon="">7-Apache Hive SQL DQL、参数配置与函数</h1>
<div class="header-meta">
<div class="header-tags">
</div>
<div class="timestamps"><div><i icon-name="calendar-plus"></i> <span class="human-date" data-date="2025-06-09T10:30:37.823+08:00"></span></div><div><i icon-name="calendar-clock"></i> <span class="human-date" data-date="2025-04-13T17:30:43.000+08:00"></span></div></div></div>
</header>
<h3 id="hadoop-day07-apache-hive-sql-dql" tabindex="-1">hadoop离线day07-Apache Hive SQL DQL、参数配置与函数</h3>
<hr>
<h4 id="今日课程学习目标" tabindex="-1">今日课程学习目标</h4>
<pre><code class="language-shell"><a class="tag" onclick="toggleTagSearch(this)" data-content="#掌握HiveQL">#掌握HiveQL</a> DQL查询语句
	基础select查询语法和MySQL一样 
	侧重记忆不一样的（见下面大纲）
<a class="tag" onclick="toggleTagSearch(this)" data-content="#掌握HiveSQL">#掌握HiveSQL</a> join查询
	重点是内关联、左关联
<a class="tag" onclick="toggleTagSearch(this)" data-content="#学会Hive">#学会Hive</a> shell命令行与参数配置
<a class="tag" onclick="toggleTagSearch(this)" data-content="#理解函数分类标准">#理解函数分类标准</a>(UDF、UDTF、UDAF)
	根据函数输入和输出的行数
		一进一出
		一进多出
		多进一出
<a class="tag" onclick="toggleTagSearch(this)" data-content="#掌握常用函数的使用">#掌握常用函数的使用</a>
	见多识广，多用多会，不用就忘
</code></pre>
<h4 id="今日课程内容大纲" tabindex="-1">今日课程内容大纲</h4>
<pre><code class="language-shell"><a class="tag" onclick="toggleTagSearch(this)" data-content="#1、PyCharm|IDEA">#1、PyCharm|IDEA</a> Hive插件
	支持HQL语法，作为客户端访问HS2
<a class="tag" onclick="toggleTagSearch(this)" data-content="#2、HQL">#2、HQL</a> DQL 数据查询语言
	cluster by
	distribute by+sort by
	order by
	union
	CTE
	Hive的join语法
<a class="tag" onclick="toggleTagSearch(this)" data-content="#3、hive的shell命令行和参数配置方式">#3、hive的shell命令行和参数配置方式</a>
<a class="tag" onclick="toggleTagSearch(this)" data-content="#4、Hive的函数">#4、Hive的函数</a>
	函数分类：内置函数、用户定义函数
	UDF、UDTF、UDAF
</code></pre>
<hr>
<h4 id="01-hive-sql-dql" tabindex="-1">知识点01：Hive SQL--DQL--基础查询语句及其注意事项</h4>
<p>1.1、select语法树</p>
<pre><code class="language-sql">SELECT [ALL | DISTINCT] select_expr, select_expr, ...
FROM table_reference
JOIN table_other ON expr
[WHERE where_condition]
[GROUP BY col_list [HAVING condition]]
[CLUSTER BY col_list
| [DISTRIBUTE BY col_list] [SORT BY| ORDER BY col_list]
]
[LIMIT number]
</code></pre>
<ul>
<li>
<p>不管是写select语句还是看select语句，==<strong>from关键字</strong>==及后面的表是最重要；</p>
</li>
<li>
<p>其后面的表可能是一张真实物理存在的表，也可能是虚拟的表（查询的结果 视图view）</p>
</li>
<li>
<p>select基础语法</p>
</li>
</ul>
<h5 id="sql" tabindex="-1">⭐⭐SQL的重点⭐⭐</h5>
<ul>
<li><strong><mark>where语句中为什么不能使用聚合函数？</mark></strong>
<ul>
<li><strong>因为聚合函数要使用它的前提是结果集已经确定。而where子句还处于“确定”结果集的过程中，因而不能使用聚合函数。</strong></li>
</ul>
</li>
<li><strong><mark>Having和where的区别？</mark></strong>
<ul>
<li>having在分组后对数据进行过滤，能使用聚合函数，where在分组前对数据过滤，不能使用聚合函数</li>
<li><strong>HAVING子句可以让我们筛选分组后的各组数据,并且可以在Having中使用聚合函数，因为此时where，group by已经执行结束，结果集已经确定。</strong></li>
</ul>
</li>
<li><strong><mark>group by语法中的查询字段的限制？为什么要求是分组字段或者是聚合函数应用的字段</mark></strong>
<ul>
<li>一个分组中非分组字段和聚合函数字段会有多个值，但在查询后每组只占一行，所以冲突无法显示</li>
<li>省流：<strong>避免出现一个字段多个值的歧义</strong></li>
</ul>
</li>
<li><strong><mark>梳理执行顺序？</mark></strong>
<ul>
<li>顺序：from〉where〉group（含聚合）&gt;having&gt;order〉select；</li>
</ul>
</li>
</ul>
<hr>
<h4 id="02-hive-sql-dql-cluster-distribute-sort" tabindex="-1">知识点02：Hive SQL--DQL--高阶查询--cluster、distribute、sort</h4>
<p><mark>CLUSTER BY 分桶查询</mark></p>
<blockquote>
<p>为了探究底层细节，建议使用beeline客户端练习 方面查看查询过程日志。</p>
</blockquote>
<ul>
<li>
<p>语法</p>
<pre><code class="language-sql">select * from student;  --普通查询
select * from student cluster by num; --分桶查询 根据学生编号进行分桶查询
</code></pre>
<p>Q：分为几个部分？ 分的规则是什么？<br>
- 分为几个部分取决于reducetask个数<br>
- 分的规则和分桶表的规则一样 hashfunc(字段) % reducetask个数</p>
</li>
<li>
<p>reducetask个数是如何确定的？ reducetask个数就决定了最终数据分为几桶。</p>
<pre><code class="language-sql">--如果用户没有设置,不指定reduce task个数。则hive根据表输入数据量自己评估
--日志显示：Number of reduce tasks not specified. Estimated from input data size: 1
select * from student cluster by num;

--手动设置reduce task个数
--日志显示：Number of reduce tasks not specified. Defaulting to jobconf value of: 2
set mapreduce.job.reduces =2;
select * from student cluster by num;
----分桶查询的结果真的根据reduce tasks个数分为了两个部分，并且每个部分中还根据了字段进行了排序。

--总结：cluster by xx  分且排序的功能
	  分为几个部分 取决于reducetask个数
	  排序只能是正序 用户无法改变
	   
--需求：把student表数据根据num分为两个部分，每个部分中根据年龄age倒序排序。	
set mapreduce.job.reduces =2;
select  * from student cluster by num order by age desc;
select  * from student cluster by num sort by age desc;
--FAILED: SemanticException 1:50 Cannot have both CLUSTER BY and SORT BY clauses

</code></pre>
</li>
</ul>
<p><mark>DISTRIBUTE BY+SORT BY</mark></p>
<ul>
<li>
<p>功能：相当于把cluster by的功能一分为二。</p>
<ul>
<li>distribute by只负责分;</li>
<li>sort by只负责分之后的每个部分排序。</li>
<li>并且分和排序的字段可以不一样。</li>
</ul>
<pre><code class="language-sql">--当后面分和排序的字段是同一个字段 加起来就相等于cluster by
CLUSTER BY(分且排序) = DISTRIBUTE BY（分）+SORT BY（排序） 

--下面两个功能一样的
select  * from student cluster by num;
select  * from student distribute by num sort by num;

--最终实现
select  * from student distribute by num sort by age desc;
</code></pre>
</li>
<li>
<p>ORDER BY</p>
<pre><code class="language-sql">--首先我们设置一下reducetask个数，随便设置
--根据之前的探讨，貌似用户设置几个，结果就是几个，但是实际情况如何呢？
set mapreduce.job.reduces =2;
select  * from student order by age desc;

--执行中日志显示
Number of reduce tasks determined at compile time: 1 --不是设置了为2吗 

--原因：order by是全局排序。全局排序意味着数据只能输出在一个文件中。因此也只能有一个reducetask.
--在order by出现的情况下，不管用户设置几个reducetask,在编译执行期间都会变为一个，满足全局。
</code></pre>
<ul>
<li>order by 和sort by
<ul>
<li>order by负责<mark>全局排序</mark> 意味着整个mr作业只有一个reducetask 不管用户设 置几个 编译期间hive都会把它设置为1。</li>
<li>sort by负责分完之后 局部排序。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image.png"><source media="(max-width:480px)" srcset="/img/optimized/CARahespZr-500.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/CARahespZr-500.jpeg">
<source media="(max-width:1920px)" srcset="/img/optimized/CARahespZr-700.webp" type="image/webp"><source media="(max-width:1920px)" srcset="/img/optimized/CARahespZr-700.jpeg"><img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image.png" width=""></picture></p>
<hr>
<h4 id="03-hive-sql-dql-union" tabindex="-1">知识点03：Hive SQL--DQL--高阶查询--Union联合查询</h4>
<p>注意合并细节</p>
<p>完整版select语法树</p>
<pre><code class="language-sql">[WITH CommonTableExpression (, CommonTableExpression)*]
SELECT [ALL | DISTINCT] select_expr, select_expr, ...
  FROM table_reference
  [WHERE where_condition]
  [GROUP BY col_list]
  [ORDER BY col_list]
  [CLUSTER BY col_list
    | [DISTRIBUTE BY col_list] [SORT BY col_list]
  ]
 [LIMIT [offset,] rows];
</code></pre>
<ul>
<li>union联合查询</li>
</ul>
<blockquote>
<p>UNION用于将来自<mark>多个SELECT语句的结果合并为一个结果集</mark>。</p>
</blockquote>
<pre><code class="language-sql">--语法规则
select_statement UNION [ DISTINCT|ALL ] select_statement UNION [ALL | DISTINCT] select_statement ...;

--使用DISTINCT关键字与使用UNION默认值效果一样，都会删除重复行。
select num,name from student_local
UNION
select num,name from student_hdfs;
--和上面一样
select num,name from student_local
UNION DISTINCT
select num,name from student_hdfs;

--使用ALL关键字会保留重复行。
select num,name from student_local
UNION ALL
select num,name from student_hdfs limit 2;

--如果要将ORDER BY，SORT BY，CLUSTER BY，DISTRIBUTE BY或LIMIT应用于单个SELECT
--请将子句放在括住SELECT的括号内
SELECT num,name FROM (select num,name from student_local LIMIT 2)  subq1
UNION
SELECT num,name FROM (select num,name from student_hdfs LIMIT 3) subq2;

--如果要将ORDER BY，SORT BY，CLUSTER BY，DISTRIBUTE BY或LIMIT子句应用于整个UNION结果
--请将ORDER BY，SORT BY，CLUSTER BY，DISTRIBUTE BY或LIMIT放在最后一个之后。
select num,name from student_local
UNION
select num,name from student_hdfs
order by num desc;
</code></pre>
<hr>
<h4 id="04-hive-sql-dql-cte" tabindex="-1">知识点04：Hive SQL--DQL--高阶查询--CTE表达式</h4>
<div class="callout" data-callout="important"><div class="callout-title"><div class="callout-title-inner">Important</div></div>
<div class="callout-content">
<p>
通用表表达式（CTE）是一个临时结果集，该结果集是从<mark>WITH子句中指定的简单查询</mark><br>
<mark>派生而来的</mark>，该查询紧接在SELECT或INSERT关键字之前。</p>
<p>通俗解释：sql开始前定义一个SQL片断，该SQL片断可以被后续整个SQL语句所用到，并且可以多次使用。</p>
</div></div>
<pre><code class="language-sql">--select语句中的CTE
with q1 as (select num,name,age from student where num = 95002)
select *
from q1;

-- from风格
with q1 as (select num,name,age from student where num = 95002)
from q1
select *;

-- chaining CTEs 链式
with q1 as ( select * from student where num = 95002),
     q2 as ( select num,name,age from q1)
select * from (select num from q2) a;

-- union
with q1 as (select * from student where num = 95002),
     q2 as (select * from student where num = 95004)
select * from q1 union all select * from q2;

-- ctas  ⭐⭐⭐⭐⭐
-- creat table as select 创建一张表来自于后面的查询语句  表的字段个数 名字 顺序和数据行数都取决于查询
-- create table t_ctas as select num,name from student limit 2;

create table s2 as
with q1 as ( select * from student where num = 95002)
select * from q1;

-- view
create view v1 as
with q1 as ( select * from student where num = 95002)
select * from q1;

select * from v1;
</code></pre>
<p>CTAS语法<br>
<picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-1.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-1.png"><source media="(max-width:480px)" srcset="/img/optimized/P4JcP6Ifxb-500.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/P4JcP6Ifxb-500.jpeg">
<source media="(max-width:1920px)" srcset="/img/optimized/P4JcP6Ifxb-700.webp" type="image/webp"><source media="(max-width:1920px)" srcset="/img/optimized/P4JcP6Ifxb-700.jpeg"><img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-1.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-1.png" width=""></picture></p>
<hr>
<h4 id="05-hive-sql-dql-join-inner-left" tabindex="-1">知识点05：Hive SQL--DQL--Join语法及其使用（侧重inner、left）</h4>
<blockquote>
<p>数据库《三大范式设计》</p>
</blockquote>
<pre><code class="language-sql">--为什么在SQL类语言中有join语法出现？
基于sql业务的实际使用，针对不同的业务创建不同的表，数据保存在不同的表中。
有的业务需求基于多份数据共同组合查询才能返回，基于多张表进行查询，所以有了join关联查询。
</code></pre>
<ul>
<li>
<p>语法树</p>
<pre><code class="language-sql">join_table:
    table_reference [INNER] JOIN table_factor [join_condition]
  | table_reference {LEFT|RIGHT|FULL} [OUTER] JOIN table_reference join_condition
  | table_reference LEFT SEMI JOIN table_reference join_condition
  | table_reference CROSS JOIN table_reference [join_condition] (as of Hive 0.10)
 
join_condition:
    ON expression
</code></pre>
</li>
<li>
<p>具体6种join方式，重点掌握 <mark>inner 和left join</mark>（左连接以左表为准，右表有满足的则显示，没有则返回null）。</p>
</li>
<li>
<p><picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-2.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-2.png"><source media="(max-width:480px)" srcset="/img/optimized/q4wDTSa9Wj-500.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/q4wDTSa9Wj-500.jpeg">
<source media="(max-width:1920px)" srcset="/img/optimized/q4wDTSa9Wj-700.webp" type="image/webp"><source media="(max-width:1920px)" srcset="/img/optimized/q4wDTSa9Wj-700.jpeg"><img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-2.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-2.png" width=""></picture></p>
</li>
<li>
<p>全外连接：把A和B去掉重复</p>
<ul>
<li>在功能上：等价于对这两个数据集合分别进行左外连接和右外连接，然后再使用消去重复行的操作将上述两个结果集合并为一个结果集。</li>
</ul>
</li>
<li>
<p>左半开连接：</p>
<ul>
<li>执行内连接后只显示左表的记录</li>
</ul>
</li>
<li>
<p>cross join：慎用2w×5w=10亿</p>
</li>
</ul>
<pre><code class="language-sql">--Join语法练习 建表
drop table if exists employee_address;
drop table if exists employee_connection;
drop table if exists employee;

--table1: 员工表
CREATE TABLE employee(
   id int,
   name string,
   deg string,
   salary int,
   dept string
 ) row format delimited
fields terminated by ',';

--table2:员工家庭住址信息表
CREATE TABLE employee_address (
    id int,
    hno string,
    street string,
    city string
) row format delimited
fields terminated by ',';

--table3:员工联系方式信息表
CREATE TABLE employee_connection (
    id int,
    phno string,
    email string
) row format delimited
fields terminated by ',';

--加载数据到表中
load data local inpath '/root/hivedata/employee.txt' into table employee;
load data local inpath '/root/hivedata/employee_address.txt' into table employee_address;
load data local inpath '/root/hivedata/employee_connection.txt' into table employee_connection;

select * from employee;
+--------------+----------------+---------------+------------------+----------------+
| employee.id  | employee.name  | employee.deg  | employee.salary  | employee.dept  |
+--------------+----------------+---------------+------------------+----------------+
| 1201         | gopal          | manager       | 50000            | TP             |
| 1202         | manisha        | cto           | 50000            | TP             |
| 1203         | khalil         | dev           | 30000            | AC             |
| 1204         | prasanth       | dev           | 30000            | AC             |
| 1206         | kranthi        | admin         | 20000            | TP             |
| 1201         | gopal          | manager       | 50000            | TP             |
| 1202         | manisha        | cto           | 50000            | TP             |
| 1203         | khalil         | dev           | 30000            | AC             |
| 1204         | prasanth       | dev           | 30000            | AC             |
| 1206         | kranthi        | admin         | 20000            | TP             |
+--------------+----------------+---------------+------------------+----------------+

select * from employee_address;


select * from employee_connection;

</code></pre>
<pre><code class="language-sql">--1、内连接  inner join == join
  返回左右两边同时满足条件的数据
  
select e.*,e_a.*
from employee e inner join employee_address e_a
on e.id =e_a.id;

--等价于 inner join
select e.*,e_a.*
from employee e join employee_address e_a
on e.id =e_a.id;

--等价于 隐式连接表示法
select e.*,e_a.*
from employee e , employee_address e_a
where e.id =e_a.id;

  
--2、左连接  left join  ==  left OUTER join
  左表为准，左表全部显示，右表与之关联 满足条件的返回，不满足条件显示null
  
select e.*,e_conn.*
from employee e left join employee_connection e_conn
on e.id =e_conn.id;

--等价于 left outer join 左外连接
select e.id,e.*,e_conn.*
from employee e left outer join  employee_connection e_conn
on e.id =e_conn.id;  
  
--3、右连接  right join  ==  right OUTER join 右外连接
  右表为准，右表全部显示，左表与之关联 满足条件的返回，不满足条件显示null
 
select e.id,e.*,e_conn.*
from employee e right join employee_connection e_conn
on e.id =e_conn.id;

--等价于 right outer join
select e.id,e.*,e_conn.*
from employee e right outer join employee_connection e_conn
on e.id =e_conn.id;

--4、外连接 全外连接 full join == full outer join
FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行.
FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。

select e.*,e_a.*
from employee e full outer join employee_address e_a
on e.id =e_a.id;
--等价于
select e.*,e_a.*
from employee e full join employee_address e_a
on e.id =e_a.id;

--5、左半连接 left semi join

select *
from employee e left semi join employee_address e_addr
on e.id =e_addr.id;

--相当于 inner join,但是只返回左表全部数据， 只不过效率高一些
select e.*
from employee e inner join employee_address e_addr
on e.id =e_addr.id;

--6、交叉连接cross join
将会返回被连接的两个表的笛卡尔积，返回结果的行数等于两个表行数的乘积。对于大表来说，cross join慎用。
在SQL标准中定义的cross join就是无条件的inner join。返回两个表的笛卡尔积,无需指
定关联键。
在HiveSQL语法中，cross join 后面可以跟where子句进行过滤，或者on条件过滤。
</code></pre>
<hr>
<h4 id="06-hive-sql-dql-join" tabindex="-1">知识点06：Hive SQL--DQL--Join语法注意事项</h4>
<ul>
<li>
<p>优化方式在最后一天调优课程中学习；</p>
</li>
<li>
<p>允许使用复杂的联接表达式，支持非等值连接；</p>
</li>
<li>
<p>同一查询中可以连接2个以上的表；</p>
</li>
<li>
<p>如果每个表在联接子句中使用相同的列，则Hive将多个表上的联接转换为单个MR作业<picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-3.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-3.png"><source media="(max-width:480px)" srcset="/img/optimized/M4SifGcdUE-500.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/M4SifGcdUE-500.jpeg">
<source media="(max-width:1920px)" srcset="/img/optimized/M4SifGcdUE-583.webp" type="image/webp"><source media="(max-width:1920px)" srcset="/img/optimized/M4SifGcdUE-583.jpeg"><img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-3.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-3.png" width=""></picture></p>
</li>
<li>
<p>join时的最后一个表会通过reducer流式传输，并在其中缓冲之前的其他表，因此，将大表放置在最后有助于减少reducer阶段缓存数据所需要的内存<picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-5.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-5.png"><source media="(max-width:480px)" srcset="/img/optimized/y8EKrDuIhk-500.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/y8EKrDuIhk-500.jpeg">
<source media="(max-width:1920px)" srcset="/img/optimized/y8EKrDuIhk-700.webp" type="image/webp"><source media="(max-width:1920px)" srcset="/img/optimized/y8EKrDuIhk-700.jpeg"><img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-5.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-5.png" width=""></picture></p>
</li>
<li>
<p>在join的时候，可以通过语法STREAMTABLE提示指定要流式传输的表。如果省略STREAMTABLE提示，则Hive将流式传输最右边的表。<picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-6.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-6.png"><source media="(max-width:480px)" srcset="/img/optimized/YLKn6MlEdD-500.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/YLKn6MlEdD-500.jpeg">
<source media="(max-width:1920px)" srcset="/img/optimized/YLKn6MlEdD-700.webp" type="image/webp"><source media="(max-width:1920px)" srcset="/img/optimized/YLKn6MlEdD-700.jpeg"><img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-6.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-6.png" width=""></picture></p>
</li>
</ul>
<hr>
<h4 id="07-hive-sql" tabindex="-1">知识点07：Hive SQL--第一代客户端的功能</h4>
<blockquote>
<p><mark>批处理</mark>：一次连接，一次交互， 执行结束断开连接<br>
<mark>交互式处理</mark>：保持持续连接， 一直交互</p>
<p>注意：如果说hive的shell客户端 指的是第一代客户端bin/hive</p>
<p>而第二代客户端bin/beeline属于JDBC客户端 不是shell。</p>
</blockquote>
<p><mark><strong>bin/hive</strong></mark></p>
<ul>
<li>
<p>功能1：作为<mark>第一代客户端</mark> 连接访问<mark>metastore服务</mark>，使用Hive。交互式方式</p>
</li>
<li>
<p>功能2：启动hive服务</p>
<pre><code class="language-shell">/export/server/apache-hive-3.1.2-bin/bin/hive --service metastore 
/export/server/apache-hive-3.1.2-bin/bin/hive --service hiveserver2 
</code></pre>
</li>
<li>
<p>功能3：批处理执行Hive SQL 命令后加-e后跟命令，-f后跟脚本文件</p>
<pre><code class="language-shell"><a class="tag" onclick="toggleTagSearch(this)" data-content="#-e">#-e</a> 执行后面的sql语句
/export/server/apache-hive-3.1.2-bin/bin/hive  -e 'select * from itheima.student'

<a class="tag" onclick="toggleTagSearch(this)" data-content="#-f">#-f</a> 执行后面的sql文件
vim hive.sql
select * from itheima.student limit 2

/export/server/apache-hive-3.1.2-bin/bin/hive  -f hive.sql

<a class="tag" onclick="toggleTagSearch(this)" data-content="#sql文件不一定是">#sql文件不一定是</a>.sql 要保证文件中是正确的HQL语法。

<a class="tag" onclick="toggleTagSearch(this)" data-content="#-f调用sql文件执行的方式">#-f调用sql文件执行的方式</a> 是企业中hive生产环境主流的调用方式。
</code></pre>
</li>
</ul>
<hr>
<h4 id="08-hive-sql" tabindex="-1">知识点08：Hive SQL--参数配置方式与优先级范围</h4>
<ul>
<li>
<p>有哪些参数可以配置？</p>
<pre><code>https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties
</code></pre>
</li>
<li>
<p>配置方式有哪些？ 注意配置方式影响范围影响时间是怎样？</p>
<ul>
<li>
<p>方式1：配置文件 con/<mark>hive-site.xml</mark></p>
<pre><code>影响的是基于这个安装包的任何使用方式。
</code></pre>
</li>
<li>
<p>方式2：配置参数 <mark>--hiveconf</mark></p>
<pre><code class="language-shell">/export/server/apache-hive-3.1.2-bin/bin/hive --service metastore  

/export/server/apache-hive-3.1.2-bin/bin/hive --service hiveserver2  --hiveconf hive.root.logger=DEBUG,console

<a class="tag" onclick="toggleTagSearch(this)" data-content="#影响的是session会话级别的">#影响的是session会话级别的</a>
</code></pre>
</li>
<li>
<p>方式3：<mark>set命令</mark></p>
<pre><code>session会话级别的 设置完之后将会对后面的sql执行生效。
session结束 set设置的参数将失效。

也是推荐搭建使用的设置参数方式。  谁需要 谁设置 谁生效
</code></pre>
</li>
</ul>
</li>
<li>
<p>总结</p>
<ul>
<li>从方式1到方式3 <mark>影响的范围是越来越小的</mark>。</li>
<li>从方式1到方式3 优先级越来越高。set命令设置的会覆盖其他的。</li>
<li>Hive作为的基于Hadoop的数仓，也会<mark>把Hadoop 的相关配置 解析加载</mark>进来。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="09-hive-sql" tabindex="-1">知识点09：Hive SQL--内置常见运算符</h4>
<ul>
<li>
<p>官方链接：<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF" target="_blank" class="external-link">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF</a></p>
</li>
<li>
<p>查看运算符和函数的帮助手册</p>
</li>
<li>
<p>可以使用课程资料中中文版参考手册</p>
<pre><code class="language-sql">--显示所有的函数和运算符
show functions;
--查看运算符或者函数的使用说明
describe function +;
--使用extended 可以查看更加详细的使用说明
describe function extended +;
</code></pre>
</li>
<li>
<p>具体分类</p>
<ul>
<li>关系运算符</li>
<li>算术运算符</li>
<li>逻辑运算符</li>
</ul>
</li>
</ul>
<pre><code class="language-sql">--1、创建表dual
create table dual(id string);
--2、加载一个文件dual.txt到dual表中
--dual.txt只有一行内容：内容为一个空格
load data local inpath '/root/hivedata/dual.txt' into table dual;
--3、在select查询语句中使用dual表完成运算符、函数功能测试
select 1+1 from dual;

select 1+1;

----------------Hive中关系运算符--------------------------
--is null空值判断
select 1 from dual where 'itcast' is null;

--is not null 非空值判断
select 1 from dual where 'itcast' is not null;

--like比较： _表示任意单个字符 %表示任意数量字符
- 在mysql中叫模糊查询
--否定比较： NOT A like B
select 1 from dual where 'itcast' like 'it_';
select 1 from dual where 'itcast' like 'it%';
select 1 from dual where  'itcast' not like 'hadoo_';
select 1 from dual where  not 'itcast' like 'hadoo_';

- rlike：确定字符串是否匹配正则表达式，是REGEXP_LIKE()的同义词。
select 1 from dual where 'itcast' rlike '^i.*t

-----

#### 知识点10：Hive SQL--函数及分类标准（UDF、UDAF、UDTF）

内置的函数（==build in func==）

&gt; 所谓的内置指的是hive开发好，可以直接上手使用的；

- 内置函数往往根据函数的应用功能类型来分类
- 日期函数、数字函数、字符串函数、集合函数、条件函数....



用户定义函数（==user-defined function==）

&gt; 用户编程实现函数的逻辑在hive中使用。

- UDF根据函数==输入行数和输出行数==进行分类

- UDF 、UDAF、UDTF![7-Apache Hive SQL DQL、参数配置与函数_image-7.png](/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-7.png)

  ```shell
  <a class="tag" onclick="toggleTagSearch(this)" data-content="#1、UDF（User-Defined-Function）普通函数">#1、UDF（User-Defined-Function）普通函数</a> 一进一出  输入一行数据输出一行数据
  
  0: jdbc:hive2://node1:10000&gt; select split(&quot;allen woon hadoop&quot;,&quot; &quot;);
  +----------------------------+--+
  |            _c0             |
  +----------------------------+--+
  | [&quot;allen&quot;,&quot;woon&quot;,&quot;hadoop&quot;]  |
  +----------------------------+--+
  
  <a class="tag" onclick="toggleTagSearch(this)" data-content="#2、UDAF（User-Defined">#2、UDAF（User-Defined</a> Aggregation Function）聚合函数，多进一出 输入多行输出一行
  
  count sum max  min  avg
  
  <a class="tag" onclick="toggleTagSearch(this)" data-content="#3、UDTF（User-Defined">#3、UDTF（User-Defined</a> Table-Generating Functions）表生成函数 一进多出 输入一行输出多行
  
  explode 、parse_url_tuple
</code></pre>
<p><mark><strong>UDF分类标准的扩大化</strong></mark></p>
<ul>
<li>本来，udf/udtf/udaf3个标准是针对用户自定义函数分类的；</li>
<li>但是，现在可以将这个分类标准扩大到<mark>hive中所有的函数，包括内置函数和自定义函数</mark>；</li>
<li>不要被UD这两个字母所影响。 Built-in Aggregate Functions (UDAF).</li>
</ul>
<p>函数相关的常用帮助命令</p>
<pre><code class="language-sql">--显示所有的函数和运算符
show functions;
--查看运算符或者函数的使用说明
describe function +;
desc function 
--使用extended 可以查看更加详细的使用说明
describe function extended count;
</code></pre>
<hr>
<h4 id="11-hive-sql" tabindex="-1">知识点11：Hive SQL--常用内置函数梳理--字符串函数</h4>
<pre><code class="language-sql">
desc function extended concat_ws;
-- 注意：查看一个函数的使用方法究竞看什么？
-- 看方法的签名列表concat_ws（separator，[string|array（string)]+)
什么是签名列表：（函数或者方法需要几个参数，什么类型的参数，参数的顺序）


-- StringFunctions字符串函数--
select concat(&quot;angela&quot;,&quot;baby&quot;);
-- 带分隔符字符串连接函数：concat_ws（separator，[string|array(string)】+)
select concat_ws（'.','www',array('itcast', 'cn'));


--字符串截取函数：substr(str, pos[, len]) 或者  substring(str, pos[, len])
select substr(&quot;angelababy&quot;,-2); --pos是从1开始的索引，如果为负数则倒着数
select substr(&quot;angelababy&quot;,2,2);


正则表达式替换函数：regexp_replace(str, regexp, rep)
select regexp_replace('100-200', '(\\d+)', 'num'); --正则分组
                                  所有数字替换成'num'：'num-num'

--正则表达式解析函数：regexp_extract(str, regexp[, idx]) 提取正则匹配到的指定组内容
select regexp_extract('100-200', '(\\d+)-(\\d+)', 2);


URL解析函数：parse_url 注意要想一次解析出多个 可以使用parse_url_tuple这个UDTF函数
select parse_url('http://www.itcast.cn/path/p1.php?query=1', 'HOST'); 
select parse_url('http://www.itcast.cn/path/p1.php?query=1', 'PATH');


分割字符串函数: split(str, regex)： regex表示支持正则
select split('apache hive', '\\s+'); --匹配一个或者多个空白符
                    **记住**：'\s'表示：匹配任何空白字符，包括空格、制表符、换页符等等

--json解析函数：get_json_object(json_txt, path)
--$表示json对象
select get_json_object('[{&quot;website&quot;:&quot;www.itcast.cn&quot;,&quot;name&quot;:&quot;allenwoon&quot;}, {&quot;website&quot;:&quot;cloud.itcast.com&quot;,&quot;name&quot;:&quot;carbondata 中文文档&quot;}]', '$.[1].website');

</code></pre>
<hr>
<h4 id="12-hive-sql" tabindex="-1">知识点12：Hive SQL--内置函数梳理--时间日期、数值</h4>
<p>Date Functions 日期函数</p>
<blockquote>
<p>日期和时间戳数字之间的转换</p>
<p><mark>unix_timestamp</mark> 日期转unix时间戳</p>
<p><mark>from_unixtime</mark> unix时间戳转日期</p>
<p><mark>date_add</mark></p>
<p><mark>date_sub</mark></p>
<p><mark>datediff</mark></p>
</blockquote>
<pre><code class="language-sql">--获取当前日期: current_date
select current_date();
--获取当前时间戳: current_timestamp
--同一查询中对current_timestamp的所有调用均返回相同的值。
select current_timestamp();
--获取当前UNIX时间戳函数: unix_timestamp
select unix_timestamp();
--日期转UNIX时间戳函数: unix_timestamp

select unix_timestamp(&quot;2011-12-07 13:01:03&quot;);
👆要求日期格式必须是标准的日期格式：data 年-月-日 时:分:秒

--指定格式日期转UNIX时间戳函数: unix_timestamp
select unix_timestamp('20111207 13:01:03','yyyyMMdd HH:mm:ss');
👆自定义时间格式需要手动设置

- UNIX时间戳转日期函数: from_unixtime
select from_unixtime(1620723323);
select from_unixtime(0, 'yyyy-MM-dd HH:mm:ss'); ：'1970-01-01 00:00:00'


--日期比较函数: datediff  日期格式要求'yyyy-MM-dd HH:mm:ss' or 'yyyy-MM-dd'
select datediff('2012-12-08','2012-05-09');
--日期增加函数: date_add
select date_add('2012-02-28',10);
--日期减少函数: date_sub
select date_sub('2012-01-1',10);
</code></pre>
<hr>
<p>Mathematical Functions 数学函数</p>
<blockquote>
<p><mark>round</mark> 取整</p>
<p><mark>rand</mark> 取随机值</p>
</blockquote>
<pre><code class="language-sql">--取整函数: round  返回double类型的整数值部分 （遵循四舍五入）
select round(3.1415926);
--指定精度取整函数: round(double a, int d) 返回指定精度d的double类型
select round(3.1415926,4);
--向下取整函数: floor
select floor(3.1415926);
select floor(-3.1415926);：-4
--向上取整函数: ceil
select ceil(3.1415926);
select ceil(-3.1415926);：-3
--取随机数函数: rand 每次执行都不一样 返回一个0到1范围内的随机数
select rand();
--指定种子取随机数函数: rand(int seed) 得到一个稳定的随机数序列
select rand(5);
</code></pre>
<hr>
<h4 id="13-hive-sql" tabindex="-1">知识点13：Hive SQL--内置函数梳理--条件转换、集合、加密</h4>
<p>Conditional Functions 条件函数</p>
<blockquote>
<p><mark>都重要</mark>。尤其是case when</p>
</blockquote>
<pre><code class="language-sql">--if条件判断: if(boolean testCondition, T valueTrue, T valueFalseOrNull)
select if(1=2,100,200);
select if(sex ='男','M','W') from student limit 3; 
👆如果是男，返回m，否则w

--空判断函数: isnull( a )
select isnull(&quot;allen&quot;);
select isnull(null);

--非空判断函数: isnotnull ( a )
select isnotnull(&quot;allen&quot;);
select isnotnull(null);

-空值转换函数: nvl(T value, T default_value)
把可能存在的null值转为0，因为任何值+null则一定返回null
⭐将NULL值替换为指定的默认值，若第一个参数非NULL则返回自身，否则返回第二个参数。⭐
select nvl(&quot;allen&quot;,&quot;itcast&quot;);
select nvl(null,&quot;itcast&quot;);

--非空查找函数: COALESCE(T v1, T v2, ...)
-返回参数中的第一个非空值；如果所有值都为NULL，那么返回NULL
select COALESCE(null,11,22,33);
select COALESCE(null,null,null,33);
select COALESCE(null,null,null);

- 条件转换函数: CASE a WHEN b THEN c [WHEN d THEN e]* [ELSE f] END
简单CASE表达式，将表达式与每个WHEN后的条件匹配，返回第一个匹配的结果，否则返回ELSE值（无ELSE时默认返回NULL）。结果：mary
select case 100 when 50 then 'tom' when 100 then 'mary' else 'tim' end;
对100判断，如果是50则返回tom，如果是100则返回mary，否则返回tim，这里显然返回mary
select case sex when '男' then 'male' else 'female' end from student limit 3;
</code></pre>
<hr>
<p>Type Conversion Functions 类型转换函数</p>
<ul>
<li>
<p>前置知识：Hive中支持类型的隐式转换 有限制 自动转换 不保证成功 就显示null</p>
</li>
<li>
<p><mark>cast显示类型转换函数</mark></p>
<pre><code class="language-sql">--任意数据类型之间转换:cast
- cast属于用户的显示类型转换，hive底层还会进行隐式类型转换，可能失败
select cast(12.14 as bigint);
select cast(12.14 as string);
select cast(&quot;hello&quot; as int);
+-------+
|  _c0  |
+-------+
| NULL  |
+-------+
</code></pre>
</li>
</ul>
<hr>
<p>Data Masking Functions 数据脱敏函数</p>
<blockquote>
<p>mask脱敏 掩码处理</p>
<p>数据脱敏：<mark>让敏感数据不敏感</mark> 13455667788 ---&gt;134****7788</p>
</blockquote>
<pre><code class="language-sql">--mask
--将查询回的数据，大写字母转换为X，小写字母转换为x，数字转换为n。
select mask(&quot;abc123DEF&quot;); 输出：xxxnnnXXX
select mask(&quot;abc123DEF&quot;,'-','.','^'); 自定义替换的字母 输出：...^^^---
👆'-','.','^'表示大写字母转换为-，小写字母转换为.，数字转换为^^^


--mask_first_n(string str[, int n]
--对前n个进行脱敏替换
select mask_first_n(&quot;abc123DEF&quot;,4);

--mask_last_n(string str[, int n])
select mask_last_n(&quot;abc123DEF&quot;,4);

--mask_show_first_n(string str[, int n])
--除了前n个字符，其余进行掩码处理
select mask_show_first_n(&quot;abc123DEF&quot;,4);

--mask_show_last_n(string str[, int n])
select mask_show_last_n(&quot;abc123DEF&quot;,4);

--mask_hash(string|char|varchar str)
--返回字符串的hash编码。
select mask_hash(&quot;abc123DEF&quot;);

</code></pre>
<hr>
<p>Misc. Functions 其他杂项函数、加密函数</p>
<pre><code class="language-sql">--如果你要调用的java方法所在的jar包不是hive自带的 可以使用add jar添加进来
--hive调用java方法: java_method(class, method[, arg1[, arg2..]])
select java_method(&quot;java.lang.Math&quot;,&quot;max&quot;,11,22);

--反射函数: reflect(class, method[, arg1[, arg2..]])
select reflect(&quot;java.lang.Math&quot;,&quot;max&quot;,11,22);

--取哈希值函数:hash
select hash(&quot;allen&quot;);

--current_user()、logged_in_user()、current_database()、version()

--SHA-1加密: sha1(string/binary)
select sha1(&quot;allen&quot;);

--SHA-2家族算法加密：sha2(string/binary, int)  (SHA-224, SHA-256, SHA-384, SHA-512)
select sha2(&quot;allen&quot;,224);
select sha2(&quot;allen&quot;,512);

--crc32加密:
select crc32(&quot;allen&quot;);

--MD5加密: md5(string/binary)
select md5(&quot;allen&quot;);
</code></pre>
<p>;<br>
select 1 from dual where '123456' rlike '^\d+</p>
<hr>
<h4 id="10-hive-sql-udf-udaf-udtf" tabindex="-1">知识点10：Hive SQL--函数及分类标准（UDF、UDAF、UDTF）</h4>
<p>内置的函数（<mark>build in func</mark>）</p>
<blockquote>
<p>所谓的内置指的是hive开发好，可以直接上手使用的；</p>
</blockquote>
<ul>
<li>内置函数往往根据函数的应用功能类型来分类</li>
<li>日期函数、数字函数、字符串函数、集合函数、条件函数....</li>
</ul>
<p>用户定义函数（<mark>user-defined function</mark>）</p>
<blockquote>
<p>用户编程实现函数的逻辑在hive中使用。</p>
</blockquote>
<ul>
<li>
<p>UDF根据函数<mark>输入行数和输出行数</mark>进行分类</p>
</li>
<li>
<p>UDF 、UDAF、UDTF<picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-7.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-7.png"><source media="(max-width:480px)" srcset="/img/optimized/jVk7r1jjNI-500.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/jVk7r1jjNI-500.jpeg">
<source media="(max-width:1920px)" srcset="/img/optimized/jVk7r1jjNI-700.webp" type="image/webp"><source media="(max-width:1920px)" srcset="/img/optimized/jVk7r1jjNI-700.jpeg"><img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-7.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-7.png" width=""></picture></p>
<p>{{CODE_BLOCK_22}}</p>
</li>
</ul>
<p><mark><strong>UDF分类标准的扩大化</strong></mark></p>
<ul>
<li>本来，udf/udtf/udaf3个标准是针对用户自定义函数分类的；</li>
<li>但是，现在可以将这个分类标准扩大到<mark>hive中所有的函数，包括内置函数和自定义函数</mark>；</li>
<li>不要被UD这两个字母所影响。 Built-in Aggregate Functions (UDAF).</li>
</ul>
<p>函数相关的常用帮助命令</p>
<p>{{CODE_BLOCK_23}}</p>
<hr>
<h4 id="11-hive-sql-1" tabindex="-1">知识点11：Hive SQL--常用内置函数梳理--字符串函数</h4>
<p>{{CODE_BLOCK_24}}</p>
<hr>
<h4 id="12-hive-sql-1" tabindex="-1">知识点12：Hive SQL--内置函数梳理--时间日期、数值</h4>
<p>Date Functions 日期函数</p>
<blockquote>
<p>日期和时间戳数字之间的转换</p>
<p><mark>unix_timestamp</mark> 日期转unix时间戳</p>
<p><mark>from_unixtime</mark> unix时间戳转日期</p>
<p><mark>date_add</mark></p>
<p><mark>date_sub</mark></p>
<p><mark>datediff</mark></p>
</blockquote>
<p>{{CODE_BLOCK_25}}</p>
<hr>
<p>Mathematical Functions 数学函数</p>
<blockquote>
<p><mark>round</mark> 取整</p>
<p><mark>rand</mark> 取随机值</p>
</blockquote>
<p>{{CODE_BLOCK_26}}</p>
<hr>
<h4 id="13-hive-sql-1" tabindex="-1">知识点13：Hive SQL--内置函数梳理--条件转换、集合、加密</h4>
<p>Conditional Functions 条件函数</p>
<blockquote>
<p><mark>都重要</mark>。尤其是case when</p>
</blockquote>
<p>{{CODE_BLOCK_27}}</p>
<hr>
<p>Type Conversion Functions 类型转换函数</p>
<ul>
<li>
<p>前置知识：Hive中支持类型的隐式转换 有限制 自动转换 不保证成功 就显示null</p>
</li>
<li>
<p><mark>cast显示类型转换函数</mark></p>
<p>{{CODE_BLOCK_28}}</p>
</li>
</ul>
<hr>
<p>Data Masking Functions 数据脱敏函数</p>
<blockquote>
<p>mask脱敏 掩码处理</p>
<p>数据脱敏：<mark>让敏感数据不敏感</mark> 13455667788 ---&gt;134****7788</p>
</blockquote>
<p>{{CODE_BLOCK_29}}</p>
<hr>
<p>Misc. Functions 其他杂项函数、加密函数</p>
<p>{{CODE_BLOCK_30}}</p>
<p>; --判断是否全为数字<br>
select 1 from dual where '123456aa' rlike '^\d+</p>
<hr>
<h4 id="10-hive-sql-udf-udaf-udtf-1" tabindex="-1">知识点10：Hive SQL--函数及分类标准（UDF、UDAF、UDTF）</h4>
<p>内置的函数（<mark>build in func</mark>）</p>
<blockquote>
<p>所谓的内置指的是hive开发好，可以直接上手使用的；</p>
</blockquote>
<ul>
<li>内置函数往往根据函数的应用功能类型来分类</li>
<li>日期函数、数字函数、字符串函数、集合函数、条件函数....</li>
</ul>
<p>用户定义函数（<mark>user-defined function</mark>）</p>
<blockquote>
<p>用户编程实现函数的逻辑在hive中使用。</p>
</blockquote>
<ul>
<li>
<p>UDF根据函数<mark>输入行数和输出行数</mark>进行分类</p>
</li>
<li>
<p>UDF 、UDAF、UDTF<picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-7.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-7.png"><source media="(max-width:480px)" srcset="/img/optimized/jVk7r1jjNI-500.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/jVk7r1jjNI-500.jpeg">
<source media="(max-width:1920px)" srcset="/img/optimized/jVk7r1jjNI-700.webp" type="image/webp"><source media="(max-width:1920px)" srcset="/img/optimized/jVk7r1jjNI-700.jpeg"><img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-7.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-7.png" width=""></picture></p>
<p>{{CODE_BLOCK_22}}</p>
</li>
</ul>
<p><mark><strong>UDF分类标准的扩大化</strong></mark></p>
<ul>
<li>本来，udf/udtf/udaf3个标准是针对用户自定义函数分类的；</li>
<li>但是，现在可以将这个分类标准扩大到<mark>hive中所有的函数，包括内置函数和自定义函数</mark>；</li>
<li>不要被UD这两个字母所影响。 Built-in Aggregate Functions (UDAF).</li>
</ul>
<p>函数相关的常用帮助命令</p>
<p>{{CODE_BLOCK_23}}</p>
<hr>
<h4 id="11-hive-sql-2" tabindex="-1">知识点11：Hive SQL--常用内置函数梳理--字符串函数</h4>
<p>{{CODE_BLOCK_24}}</p>
<hr>
<h4 id="12-hive-sql-2" tabindex="-1">知识点12：Hive SQL--内置函数梳理--时间日期、数值</h4>
<p>Date Functions 日期函数</p>
<blockquote>
<p>日期和时间戳数字之间的转换</p>
<p><mark>unix_timestamp</mark> 日期转unix时间戳</p>
<p><mark>from_unixtime</mark> unix时间戳转日期</p>
<p><mark>date_add</mark></p>
<p><mark>date_sub</mark></p>
<p><mark>datediff</mark></p>
</blockquote>
<p>{{CODE_BLOCK_25}}</p>
<hr>
<p>Mathematical Functions 数学函数</p>
<blockquote>
<p><mark>round</mark> 取整</p>
<p><mark>rand</mark> 取随机值</p>
</blockquote>
<p>{{CODE_BLOCK_26}}</p>
<hr>
<h4 id="13-hive-sql-2" tabindex="-1">知识点13：Hive SQL--内置函数梳理--条件转换、集合、加密</h4>
<p>Conditional Functions 条件函数</p>
<blockquote>
<p><mark>都重要</mark>。尤其是case when</p>
</blockquote>
<p>{{CODE_BLOCK_27}}</p>
<hr>
<p>Type Conversion Functions 类型转换函数</p>
<ul>
<li>
<p>前置知识：Hive中支持类型的隐式转换 有限制 自动转换 不保证成功 就显示null</p>
</li>
<li>
<p><mark>cast显示类型转换函数</mark></p>
<p>{{CODE_BLOCK_28}}</p>
</li>
</ul>
<hr>
<p>Data Masking Functions 数据脱敏函数</p>
<blockquote>
<p>mask脱敏 掩码处理</p>
<p>数据脱敏：<mark>让敏感数据不敏感</mark> 13455667788 ---&gt;134****7788</p>
</blockquote>
<p>{{CODE_BLOCK_29}}</p>
<hr>
<p>Misc. Functions 其他杂项函数、加密函数</p>
<p>{{CODE_BLOCK_30}}</p>
<p>;</p>
<p>--regexp：功能与rlike相同 用于判断字符串是否匹配正则表达式<br>
select 1 from dual where 'itcast' regexp '^i.*t</p>
<hr>
<h4 id="10-hive-sql-udf-udaf-udtf-2" tabindex="-1">知识点10：Hive SQL--函数及分类标准（UDF、UDAF、UDTF）</h4>
<p>内置的函数（<mark>build in func</mark>）</p>
<blockquote>
<p>所谓的内置指的是hive开发好，可以直接上手使用的；</p>
</blockquote>
<ul>
<li>内置函数往往根据函数的应用功能类型来分类</li>
<li>日期函数、数字函数、字符串函数、集合函数、条件函数....</li>
</ul>
<p>用户定义函数（<mark>user-defined function</mark>）</p>
<blockquote>
<p>用户编程实现函数的逻辑在hive中使用。</p>
</blockquote>
<ul>
<li>
<p>UDF根据函数<mark>输入行数和输出行数</mark>进行分类</p>
</li>
<li>
<p>UDF 、UDAF、UDTF<picture src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-7.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-7.png"><source media="(max-width:480px)" srcset="/img/optimized/jVk7r1jjNI-500.webp" type="image/webp">
<source media="(max-width:480px)" srcset="/img/optimized/jVk7r1jjNI-500.jpeg">
<source media="(max-width:1920px)" srcset="/img/optimized/jVk7r1jjNI-700.webp" type="image/webp"><source media="(max-width:1920px)" srcset="/img/optimized/jVk7r1jjNI-700.jpeg"><img class="" src="/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-7.png" alt="7-Apache Hive SQL DQL、参数配置与函数_image-7.png" width=""></picture></p>
<p>{{CODE_BLOCK_22}}</p>
</li>
</ul>
<p><mark><strong>UDF分类标准的扩大化</strong></mark></p>
<ul>
<li>本来，udf/udtf/udaf3个标准是针对用户自定义函数分类的；</li>
<li>但是，现在可以将这个分类标准扩大到<mark>hive中所有的函数，包括内置函数和自定义函数</mark>；</li>
<li>不要被UD这两个字母所影响。 Built-in Aggregate Functions (UDAF).</li>
</ul>
<p>函数相关的常用帮助命令</p>
<p>{{CODE_BLOCK_23}}</p>
<hr>
<h4 id="11-hive-sql-3" tabindex="-1">知识点11：Hive SQL--常用内置函数梳理--字符串函数</h4>
<p>{{CODE_BLOCK_24}}</p>
<hr>
<h4 id="12-hive-sql-3" tabindex="-1">知识点12：Hive SQL--内置函数梳理--时间日期、数值</h4>
<p>Date Functions 日期函数</p>
<blockquote>
<p>日期和时间戳数字之间的转换</p>
<p><mark>unix_timestamp</mark> 日期转unix时间戳</p>
<p><mark>from_unixtime</mark> unix时间戳转日期</p>
<p><mark>date_add</mark></p>
<p><mark>date_sub</mark></p>
<p><mark>datediff</mark></p>
</blockquote>
<p>{{CODE_BLOCK_25}}</p>
<hr>
<p>Mathematical Functions 数学函数</p>
<blockquote>
<p><mark>round</mark> 取整</p>
<p><mark>rand</mark> 取随机值</p>
</blockquote>
<p>{{CODE_BLOCK_26}}</p>
<hr>
<h4 id="13-hive-sql-3" tabindex="-1">知识点13：Hive SQL--内置函数梳理--条件转换、集合、加密</h4>
<p>Conditional Functions 条件函数</p>
<blockquote>
<p><mark>都重要</mark>。尤其是case when</p>
</blockquote>
<p>{{CODE_BLOCK_27}}</p>
<hr>
<p>Type Conversion Functions 类型转换函数</p>
<ul>
<li>
<p>前置知识：Hive中支持类型的隐式转换 有限制 自动转换 不保证成功 就显示null</p>
</li>
<li>
<p><mark>cast显示类型转换函数</mark></p>
<p>{{CODE_BLOCK_28}}</p>
</li>
</ul>
<hr>
<p>Data Masking Functions 数据脱敏函数</p>
<blockquote>
<p>mask脱敏 掩码处理</p>
<p>数据脱敏：<mark>让敏感数据不敏感</mark> 13455667788 ---&gt;134****7788</p>
</blockquote>
<p>{{CODE_BLOCK_29}}</p>
<hr>
<p>Misc. Functions 其他杂项函数、加密函数</p>
<p>{{CODE_BLOCK_30}}</p>
<p>;</p>
<p>-------------------Hive中算术运算符---------------------------------<br>
--取整操作: div 给出将A除以B所得的整数部分。例如17 div 3得出5。<br>
select 17 div 3;</p>
<p>--取余操作: % 也叫做取模mod A除以B所得的余数部分<br>
select 17 % 3;</p>
<ul>
<li>
<p>位与操作: &amp; A和B按位进行与操作的结果。 与表示两个都为1则结果为1<br>
select 4 &amp; 8 from dual; --4转换二进制：0100 8转换二进制：1000<br>
select 6 &amp; 4 from dual; --4转换二进制：0100 6转换二进制：0110</p>
</li>
<li>
<p>位或操作: | A和B按位进行或操作的结果 或表示有一个为1则结果为1<br>
select 4 | 8 from dual;<br>
select 6 | 4 from dual;</p>
</li>
<li>
<p>位异或操作: ^ A和B按位进行异或操作的结果 异或表示两者的值不同,则结果为1<br>
select 4 ^ 8 from dual;<br>
select 6 ^ 4 from dual;</p>
</li>
</ul>
<p>--3、Hive逻辑运算符<br>
--与操作: A AND B 如果A和B均为TRUE，则为TRUE，否则为FALSE。如果A或B为NULL，则为NULL。<br>
select 1 from dual where 3&gt;1 and 2&gt;1;<br>
--或操作: A OR B 如果A或B或两者均为TRUE，则为TRUE，否则为FALSE。<br>
select 1 from dual where 3&gt;1 or 2!=2;<br>
--非操作: NOT A 、!A 如果A为FALSE，则为TRUE；如果A为NULL，则为NULL。否则为FALSE。<br>
select 1 from dual where not 2&gt;1;<br>
select 1 from dual where !2=1;</p>
<p>--在:A IN (val1, val2, ...) 如果A等于任何值，则为TRUE。<br>
select 1 from dual where 11 in(11,22,33);<br>
--不在:A NOT IN (val1, val2, ...) 如果A不等于任何值，则为TRUE<br>
select 1 from dual where 11 not in(22,33,44);</p>
<pre><code>
-----

#### 知识点10：Hive SQL--函数及分类标准（UDF、UDAF、UDTF）

内置的函数（==build in func==）

&gt; 所谓的内置指的是hive开发好，可以直接上手使用的；

- 内置函数往往根据函数的应用功能类型来分类
- 日期函数、数字函数、字符串函数、集合函数、条件函数....



用户定义函数（==user-defined function==）

&gt; 用户编程实现函数的逻辑在hive中使用。

- UDF根据函数==输入行数和输出行数==进行分类

- UDF 、UDAF、UDTF![7-Apache Hive SQL DQL、参数配置与函数_image-7.png](/img/user/czc%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/9-%E9%99%84%E4%BB%B6/%E9%99%84%E4%BB%B6/7-Apache%20Hive%20SQL%20DQL%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%BD%E6%95%B0_image-7.png)

  {{CODE_BLOCK_22}}



==**UDF分类标准的扩大化**==

- 本来，udf/udtf/udaf3个标准是针对用户自定义函数分类的；
- 但是，现在可以将这个分类标准扩大到==hive中所有的函数，包括内置函数和自定义函数==；
- 不要被UD这两个字母所影响。  Built-in Aggregate Functions (UDAF).



函数相关的常用帮助命令

{{CODE_BLOCK_23}}

-------

#### 知识点11：Hive SQL--常用内置函数梳理--字符串函数

{{CODE_BLOCK_24}}

-----

#### 知识点12：Hive SQL--内置函数梳理--时间日期、数值

Date Functions 日期函数

&gt; 日期和时间戳数字之间的转换 
&gt;
&gt; ==unix_timestamp==  日期转unix时间戳
&gt;
&gt; ==from_unixtime==  unix时间戳转日期
&gt;
&gt; ==date_add== 
&gt;
&gt; ==date_sub==  
&gt;
&gt; ==datediff==

{{CODE_BLOCK_25}}

---

Mathematical Functions 数学函数

&gt; ==round== 取整
&gt;
&gt; ==rand== 取随机值

{{CODE_BLOCK_26}}

-----

#### 知识点13：Hive SQL--内置函数梳理--条件转换、集合、加密

Conditional Functions 条件函数

&gt; ==都重要==。尤其是case when

{{CODE_BLOCK_27}}

-----

Type Conversion Functions 类型转换函数

- 前置知识：Hive中支持类型的隐式转换  有限制  自动转换  不保证成功  就显示null

- ==cast显示类型转换函数==

  {{CODE_BLOCK_28}}

----

Data Masking Functions 数据脱敏函数  

&gt; mask脱敏 掩码处理
&gt;
&gt; 数据脱敏：==让敏感数据不敏感==   13455667788 ---&gt;134****7788

{{CODE_BLOCK_29}}

-----

Misc. Functions 其他杂项函数、加密函数

{{CODE_BLOCK_30}}



































































</code></pre>
</main>
<aside>
<div class="sidebar">
<div class="sidebar-container">
<div class="toc">
<div class="toc-title-container">
<div class="toc-title">
On this page
</div>
</div>
<div class="toc-container">
<nav class="toc">
<ol>
<li><a href="#hadoop-day07-apache-hive-sql-dql">hadoop离线day07-Apache Hive SQL DQL、参数配置与函数</a>
<ol>
<li><a href="#今日课程学习目标">今日课程学习目标</a>
</li>
<li><a href="#今日课程内容大纲">今日课程内容大纲</a>
</li>
<li><a href="#01-hive-sql-dql">知识点01：Hive SQL--DQL--基础查询语句及其注意事项</a>
<ol>
<li><a href="#sql">⭐⭐SQL的重点⭐⭐</a>
</li>
</ol>
</li>
<li><a href="#02-hive-sql-dql-cluster-distribute-sort">知识点02：Hive SQL--DQL--高阶查询--cluster、distribute、sort</a>
</li>
<li><a href="#03-hive-sql-dql-union">知识点03：Hive SQL--DQL--高阶查询--Union联合查询</a>
</li>
<li><a href="#04-hive-sql-dql-cte">知识点04：Hive SQL--DQL--高阶查询--CTE表达式</a>
</li>
<li><a href="#05-hive-sql-dql-join-inner-left">知识点05：Hive SQL--DQL--Join语法及其使用（侧重inner、left）</a>
</li>
<li><a href="#06-hive-sql-dql-join">知识点06：Hive SQL--DQL--Join语法注意事项</a>
</li>
<li><a href="#07-hive-sql">知识点07：Hive SQL--第一代客户端的功能</a>
</li>
<li><a href="#08-hive-sql">知识点08：Hive SQL--参数配置方式与优先级范围</a>
</li>
<li><a href="#09-hive-sql">知识点09：Hive SQL--内置常见运算符</a>
</li>
<li><a href="#11-hive-sql">知识点11：Hive SQL--常用内置函数梳理--字符串函数</a>
</li>
<li><a href="#12-hive-sql">知识点12：Hive SQL--内置函数梳理--时间日期、数值</a>
</li>
<li><a href="#13-hive-sql">知识点13：Hive SQL--内置函数梳理--条件转换、集合、加密</a>
</li>
<li><a href="#10-hive-sql-udf-udaf-udtf">知识点10：Hive SQL--函数及分类标准（UDF、UDAF、UDTF）</a>
</li>
<li><a href="#11-hive-sql-1">知识点11：Hive SQL--常用内置函数梳理--字符串函数</a>
</li>
<li><a href="#12-hive-sql-1">知识点12：Hive SQL--内置函数梳理--时间日期、数值</a>
</li>
<li><a href="#13-hive-sql-1">知识点13：Hive SQL--内置函数梳理--条件转换、集合、加密</a>
</li>
<li><a href="#10-hive-sql-udf-udaf-udtf-1">知识点10：Hive SQL--函数及分类标准（UDF、UDAF、UDTF）</a>
</li>
<li><a href="#11-hive-sql-2">知识点11：Hive SQL--常用内置函数梳理--字符串函数</a>
</li>
<li><a href="#12-hive-sql-2">知识点12：Hive SQL--内置函数梳理--时间日期、数值</a>
</li>
<li><a href="#13-hive-sql-2">知识点13：Hive SQL--内置函数梳理--条件转换、集合、加密</a>
</li>
<li><a href="#10-hive-sql-udf-udaf-udtf-2">知识点10：Hive SQL--函数及分类标准（UDF、UDAF、UDTF）</a>
</li>
<li><a href="#11-hive-sql-3">知识点11：Hive SQL--常用内置函数梳理--字符串函数</a>
</li>
<li><a href="#12-hive-sql-3">知识点12：Hive SQL--内置函数梳理--时间日期、数值</a>
</li>
<li><a href="#13-hive-sql-3">知识点13：Hive SQL--内置函数梳理--条件转换、集合、加密</a>
</li>
</ol>
</li>
</ol>
</nav>
</div>
</div>
<div class="backlinks">
<div class="backlink-title" style="margin:4px 0!important">Pages mentioning this page</div>
<div class="backlink-list"><div class="backlink-card"><i icon-name="link"></i><a href="/czc知识库/计算机/Hadoop技术栈/Hadoop技术栈/" data-note-icon="" class="backlink">Hadoop技术栈</a>
</div></div>
</div>
</div>
</div>
</aside>
<style>#tooltip-wrapper{background:var(--background-primary);padding:1em;border-radius:4px;overflow:hidden;position:fixed;width:80%;max-width:400px;height:auto;max-height:300px;font-size:.8em;box-shadow:0 5px 10px rgba(0,0,0,.1);opacity:0;transition:opacity .1s;unicode-bidi:plaintext;overflow-y:scroll;z-index:10}#tooltip-wrapper:after{content:"";position:absolute;z-index:1;bottom:0;left:0;pointer-events:none;width:100%;unicode-bidi:plaintext;height:75px}</style>
<div style="opacity:0;display:none" id="tooltip-wrapper">
<div id="tooltip-content">
</div>
</div>
<iframe style="display:none;height:0;width:0" id="link-preview-iframe" src="">
</iframe>
<script>var opacityTimeout,contentTimeout,transitionDurationMs=100,iframe=document.getElementById("link-preview-iframe"),tooltipWrapper=document.getElementById("tooltip-wrapper"),tooltipContent=document.getElementById("tooltip-content"),linkHistories={};function hideTooltip(){opacityTimeout=setTimeout((function(){tooltipWrapper.style.opacity=0,contentTimeout=setTimeout((function(){tooltipContent.innerHTML="",tooltipWrapper.style.display="none"}),transitionDurationMs+1)}),transitionDurationMs)}function showTooltip(t){var e=t.target,o=e.getClientRects()[e.getClientRects().length-1],i=window.pageYOffset||document.documentElement.scrollTop,n=t.target.getAttribute("href");if(-1===n.indexOf("http")||-1!==n.indexOf(window.location.host)){let t=n.split("#")[0];linkHistories[t]?(tooltipContent.innerHTML=linkHistories[t],tooltipWrapper.style.display="block",setTimeout((function(){if(tooltipWrapper.style.opacity=1,-1!=n.indexOf("#")){let t=n.split("#")[1];const e=tooltipWrapper.querySelector(`[id='${t}']`);e.classList.add("referred"),e.scrollIntoView({behavior:"smooth"},!0)}else tooltipWrapper.scroll(0,0)}),1)):(iframe.src=t,iframe.onload=function(){tooltipContentHtml="",tooltipContentHtml+='<div style="font-weight: bold; unicode-bidi: plaintext;">'+iframe.contentWindow.document.querySelector("h1").innerHTML+"</div>",tooltipContentHtml+=iframe.contentWindow.document.querySelector(".content").innerHTML,tooltipContent.innerHTML=tooltipContentHtml,linkHistories[t]=tooltipContentHtml,tooltipWrapper.style.display="block",tooltipWrapper.scrollTop=0,setTimeout((function(){if(tooltipWrapper.style.opacity=1,-1!=n.indexOf("#")){let t=n.split("#")[1];const e=tooltipWrapper.querySelector(`[id='${t}']`);e.classList.add("referred"),console.log(e),e.scrollIntoView({behavior:"smooth"},!0)}else tooltipWrapper.scroll(0,0)}),1)}),tooltipWrapper.style.left=o.left-tooltipWrapper.offsetWidth/2+o.width/2+"px",window.innerHeight-o.top<tooltipWrapper.offsetHeight?tooltipWrapper.style.top=o.top+i-tooltipWrapper.offsetHeight-10+"px":window.innerHeight-o.top>tooltipWrapper.offsetHeight&&(tooltipWrapper.style.top=o.top+i+35+"px"),o.left+o.width/2<tooltipWrapper.offsetWidth/2?tooltipWrapper.style.left="10px":document.body.clientWidth-o.left-o.width/2<tooltipWrapper.offsetWidth/2&&(tooltipWrapper.style.left=document.body.clientWidth-tooltipWrapper.offsetWidth-20+"px")}}function setupListeners(t){t.addEventListener("mouseleave",(function(t){hideTooltip()})),tooltipWrapper.addEventListener("mouseleave",(function(t){hideTooltip()})),t.addEventListener("mouseenter",(function(t){clearTimeout(opacityTimeout),clearTimeout(contentTimeout),showTooltip(t)})),tooltipWrapper.addEventListener("mouseenter",(function(t){clearTimeout(opacityTimeout),clearTimeout(contentTimeout)}))}window.addEventListener("load",(function(t){document.querySelectorAll(".internal-link").forEach(setupListeners),document.querySelectorAll(".backlink-card a").forEach(setupListeners)}))</script>
<script>window.location.hash&&document.getElementById(window.location.hash.slice(1)).classList.add("referred"),window.addEventListener("hashchange",(e=>{const t=e.oldURL.split("#");t[1]&&document.getElementById(t[1]).classList.remove("referred");const n=e.newURL.split("#");n[1]&&document.getElementById(n[1]).classList.add("referred")}),!1);const url_parts=window.location.href.split("#"),url=url_parts[0],referrence=url_parts[1];document.querySelectorAll(".cm-s-obsidian > *[id]").forEach((function(e){e.ondblclick=function(e){const t=url+"#"+e.target.id;navigator.clipboard.writeText(t)}}))</script>
<script src="https://fastly.jsdelivr.net/npm/luxon@3.2.1/build/global/luxon.min.js"></script>
<script defer="defer">TIMESTAMP_FORMAT="MMM dd, yyyy h:mm a",document.querySelectorAll(".human-date").forEach((function(e){date=e.getAttribute("data-date")||e.innerText,parsed_date=luxon.DateTime.fromISO(date),null!=parsed_date.invalid&&(parsed_date=luxon.DateTime.fromSQL(date)),null!=parsed_date.invalid&&(parsed_date=luxon.DateTime.fromHTML(date)),e.innerHTML=parsed_date.toFormat(TIMESTAMP_FORMAT)}))</script>
<script>lucide.createIcons({attrs:{class:["svg-icon"]}})</script>
</body>
</html>
